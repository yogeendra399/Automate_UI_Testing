#!/usr/bin/env node
'use strict';

var commander = require('commander');
var which = require('which');
var listr2 = require('listr2');
var chalk = require('chalk');
var path3 = require('path');
var fastify = require('fastify');
var fs6 = require('fs');
var Ajv = require('ajv');
var addErrors = require('ajv-errors');
var test = require('@playwright/test');
var util$1 = require('util');
var postcss = require('postcss');
var winston = require('winston');
var stringify = require('json-stringify-safe');
var FormData = require('form-data');
var axios = require('axios');
var https = require('https');
var child_process = require('child_process');
var spawn = require('cross-spawn');
var NodeCache = require('node-cache');
var uuid = require('uuid');
var sharp = require('sharp');
var http = require('http');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var which__default = /*#__PURE__*/_interopDefault(which);
var chalk__default = /*#__PURE__*/_interopDefault(chalk);
var path3__default = /*#__PURE__*/_interopDefault(path3);
var fastify__default = /*#__PURE__*/_interopDefault(fastify);
var fs6__default = /*#__PURE__*/_interopDefault(fs6);
var Ajv__default = /*#__PURE__*/_interopDefault(Ajv);
var addErrors__default = /*#__PURE__*/_interopDefault(addErrors);
var postcss__default = /*#__PURE__*/_interopDefault(postcss);
var stringify__default = /*#__PURE__*/_interopDefault(stringify);
var FormData__default = /*#__PURE__*/_interopDefault(FormData);
var axios__default = /*#__PURE__*/_interopDefault(axios);
var https__namespace = /*#__PURE__*/_interopNamespace(https);
var spawn__default = /*#__PURE__*/_interopDefault(spawn);
var NodeCache__default = /*#__PURE__*/_interopDefault(NodeCache);
var sharp__default = /*#__PURE__*/_interopDefault(sharp);
var http__namespace = /*#__PURE__*/_interopNamespace(http);

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/.pnpm/find-free-port@2.0.0/node_modules/find-free-port/index.js
var require_find_free_port = __commonJS({
  "node_modules/.pnpm/find-free-port@2.0.0/node_modules/find-free-port/index.js"(exports$1, module) {
    var net = __require("net");
    function findFreePort(beg, ...rest) {
      const p = rest.slice(0, rest.length - 1), cb = rest[rest.length - 1];
      let [end, ip, cnt] = Array.from(p);
      if (!ip && end && !/^\d+$/.test(end)) {
        ip = end;
        end = 65534;
      } else {
        if (end == null) {
          end = 65534;
        }
      }
      if (cnt == null) {
        cnt = 1;
      }
      const retcb = cb;
      const res = [];
      const probe = function(ip2, port, cb2) {
        const s = net.createConnection({ port, host: ip2 });
        s.on("connect", function() {
          s.end();
          cb2(null, port + 1);
        });
        s.on("error", (err) => {
          cb2(port);
        });
      };
      var onprobe = function(port, nextPort) {
        if (port) {
          res.push(port);
          if (res.length >= cnt) {
            retcb(null, ...res);
          } else {
            setImmediate(() => probe(ip, port + 1, onprobe));
          }
        } else {
          if (nextPort >= end) {
            retcb(new Error("No available ports"));
          } else {
            setImmediate(() => probe(ip, nextPort, onprobe));
          }
        }
      };
      return probe(ip, beg, onprobe);
    }
    function findFreePortPmfy(beg, ...rest) {
      const last = rest[rest.length - 1];
      if (typeof last === "function") {
        findFreePort(beg, ...rest);
      } else {
        return new Promise((resolve, reject) => {
          findFreePort(beg, ...rest, (err, ...ports) => {
            if (err)
              reject(err);
            else
              resolve(ports);
          });
        });
      }
    }
    module.exports = findFreePortPmfy;
  }
});

// src/lib/constants.ts
var constants_default = {
  // default configs
  DEFAULT_CONFIG: {
    web: {
      browsers: [
        "chrome",
        "firefox",
        "safari",
        "edge"
      ],
      viewports: [
        [1920],
        [1366],
        [1028]
      ]
    },
    mobile: {
      devices: [
        "iPhone 14",
        "Galaxy S24"
      ],
      fullPage: true,
      orientation: "portrait"
    },
    waitForTimeout: 1e3,
    enableJavaScript: false,
    allowedHostnames: [],
    smartIgnore: false,
    showRenderErrors: false
  },
  DEFAULT_WEB_STATIC_CONFIG: [
    {
      "name": "lambdatest-home-page",
      "url": "https://www.lambdatest.com",
      "waitForTimeout": 1e3
    },
    {
      "name": "example-page",
      "url": "https://example.com/"
    }
  ],
  // browsers
  CHROME: "chrome",
  SAFARI: "safari",
  FIREFOX: "firefox",
  EDGE: "edge",
  EDGE_CHANNEL: "msedge",
  WEBKIT: "webkit",
  MIN_PORT_RANGE: 49100,
  MAX_PORT_RANGE: 6e4,
  // discovery browser launch arguments
  LAUNCH_ARGS: [
    // disable the translate popup and optimization downloads
    "--disable-features=Translate,OptimizationGuideModelDownloading",
    // disable several subsystems which run network requests in the background
    "--disable-background-networking",
    // disable task throttling of timer tasks from background pages
    "--disable-background-timer-throttling",
    // disable backgrounding renderer processes
    "--disable-renderer-backgrounding",
    // disable backgrounding renderers for occluded windows (reduce nondeterminism)
    "--disable-backgrounding-occluded-windows",
    // disable crash reporting
    "--disable-breakpad",
    // disable client side phishing detection
    "--disable-client-side-phishing-detection",
    // disable default component extensions with background pages for performance
    "--disable-component-extensions-with-background-pages",
    // disable installation of default apps on first run
    "--disable-default-apps",
    // work-around for environments where a small /dev/shm partition causes crashes
    "--disable-dev-shm-usage",
    // disable extensions
    "--disable-extensions",
    // disable hang monitor dialogs in renderer processes
    "--disable-hang-monitor",
    // disable inter-process communication flooding protection for javascript
    "--disable-ipc-flooding-protection",
    // disable web notifications and the push API
    "--disable-notifications",
    // disable the prompt when a POST request causes page navigation
    "--disable-prompt-on-repost",
    // disable syncing browser data with google accounts
    "--disable-sync",
    // disable site-isolation to make network requests easier to intercept
    "--disable-site-isolation-trials",
    // disable the first run tasks, whether or not it's actually the first run
    "--no-first-run",
    // disable the sandbox for all process types that are normally sandboxed
    "--no-sandbox",
    // specify a consistent encryption backend across platforms
    "--password-store=basic",
    // use a mock keychain on Mac to prevent blocking permissions dialogs
    "--use-mock-keychain",
    // enable remote debugging on the first available port
    "--remote-debugging-port=0",
    // sets navigator.webdriver to false
    "--disable-blink-features=AutomationControlled",
    // disable UA-CH feature
    `--disable-features=UserAgentClientHint`
  ],
  // discovery request headers
  REQUEST_HEADERS: {
    // `HeadlessChrome` is added to sec-ch-ua, `--disable-features=UserAgentClientHint` doesn't seem to work
    "sec-ch-ua": '"Chromium";v="129", "Not=A?Brand";v="8"',
    "sec-ch-ua-mobile": '"?0"',
    "sec-ch-ua-platform": '"Windows"'
  },
  // user agents
  CHROME_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.107 Safari/537.3",
  FIREFOX_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:112.0) Gecko/20100101 Firefox/112.0",
  SAFARI_USER_AGENT: "Mozilla/5.0 (Macintosh; Intel Mac OS X 13_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.4 Safari/605.1.15",
  EDGE_USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.35",
  // viewports
  MIN_VIEWPORT_HEIGHT: 1080,
  // mobile
  MOBILE_OS_ANDROID: "android",
  MOBILE_OS_IOS: "ios",
  MOBILE_ORIENTATION_PORTRAIT: "portrait",
  MOBILE_ORIENTATION_LANDSCAPE: "landscape",
  // build status
  BUILD_RUNNING: "running",
  BUILD_COMPLETE: "completed",
  BUILD_ERROR: "error",
  // CI
  GITHUB_API_HOST: "https://api.github.com",
  // log file path
  LOG_FILE_PATH: ".smartui.log",
  // Disallowed file extension
  FILE_EXTENSION_ZIP: ".zip",
  FILE_EXTENSION_GIFS: "gif",
  // Default scrollTime
  DEFAULT_SCROLL_TIME: 8,
  // Default page load time
  DEFAULT_PAGE_LOAD_TIMEOUT: 18e4,
  // Magic Numbers 
  MAGIC_NUMBERS: [
    { ext: "jpg", magic: Buffer.from([255, 216, 255]) },
    { ext: "jpeg", magic: Buffer.from([255, 216, 255]) },
    { ext: "png", magic: Buffer.from([137, 80, 78, 71, 13, 10, 26, 10]) },
    { ext: "gif", magic: Buffer.from([71, 73, 70, 56]) }
  ],
  SUPPORTED_MOBILE_DEVICES: {
    "Blackberry KEY2 LE": { os: "android", viewport: { width: 412, height: 618 } },
    "Galaxy A12": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy A21s": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A22": { os: "android", viewport: { width: 358, height: 857 } },
    "Galaxy A31": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A32": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A51": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A7": { os: "android", viewport: { width: 412, height: 846 } },
    "Galaxy A70": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy A8": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy A8 Plus": { os: "android", viewport: { width: 412, height: 846 } },
    "Galaxy J7 Prime": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy M12": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy M31": { os: "android", viewport: { width: 412, height: 892 } },
    "Galaxy Note10": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy Note10 Plus": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy Note20": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy Note20 Ultra": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy S10": { os: "android", viewport: { width: 360, height: 760 } },
    "Galaxy S10 Plus": { os: "android", viewport: { width: 412, height: 869 } },
    "Galaxy S10e": { os: "android", viewport: { width: 412, height: 740 } },
    "Galaxy S20": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S20 FE": { os: "android", viewport: { width: 412, height: 914 } },
    "Galaxy S20 Ultra": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy S20 Plus": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S21": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S21 FE": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S21 Ultra": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S21 Plus": { os: "android", viewport: { width: 360, height: 800 } },
    "Galaxy S22": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S22 Ultra": { os: "android", viewport: { width: 384, height: 854 } },
    "Galaxy S23": { os: "android", viewport: { width: 360, height: 645 } },
    "Galaxy S23 Plus": { os: "android", viewport: { width: 360, height: 648 } },
    "Galaxy S23 Ultra": { os: "android", viewport: { width: 384, height: 689 } },
    "Galaxy S24": { os: "android", viewport: { width: 360, height: 780 } },
    "Galaxy S24 Plus": { os: "android", viewport: { width: 384, height: 832 } },
    "Galaxy S24 Ultra": { os: "android", viewport: { width: 384, height: 832 } },
    "Galaxy S7": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy S7 Edge": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy S8": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S8 Plus": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S9": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy S9 Plus": { os: "android", viewport: { width: 360, height: 740 } },
    "Galaxy Tab A7 Lite": { os: "android", viewport: { width: 534, height: 894 } },
    "Galaxy Tab A8": { os: "android", viewport: { width: 800, height: 1280 } },
    "Galaxy Tab S3": { os: "android", viewport: { width: 1024, height: 768 } },
    "Galaxy Tab S4": { os: "android", viewport: { width: 712, height: 1138 } },
    "Galaxy Tab S7": { os: "android", viewport: { width: 800, height: 1192 } },
    "Galaxy Tab S8": { os: "android", viewport: { width: 753, height: 1205 } },
    "Galaxy Tab S8 Plus": { os: "android", viewport: { width: 825, height: 1318 } },
    "Huawei Mate 20 Pro": { os: "android", viewport: { width: 360, height: 780 } },
    "Huawei P20 Pro": { os: "android", viewport: { width: 360, height: 747 } },
    "Huawei P30": { os: "android", viewport: { width: 360, height: 780 } },
    "Huawei P30 Pro": { os: "android", viewport: { width: 360, height: 780 } },
    "Microsoft Surface Duo": { os: "android", viewport: { width: 1114, height: 705 } },
    "Moto G7 Play": { os: "android", viewport: { width: 360, height: 760 } },
    "Moto G9 Play": { os: "android", viewport: { width: 393, height: 786 } },
    "Moto G Stylus (2022)": { os: "android", viewport: { width: 432, height: 984 } },
    "Nexus 5": { os: "android", viewport: { width: 360, height: 640 } },
    "Nexus 5X": { os: "android", viewport: { width: 412, height: 732 } },
    "Nokia 5": { os: "android", viewport: { width: 360, height: 640 } },
    "Nothing Phone (1)": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus 10 Pro": { os: "android", viewport: { width: 412, height: 919 } },
    "OnePlus 11": { os: "android", viewport: { width: 360, height: 804 } },
    "OnePlus 6": { os: "android", viewport: { width: 412, height: 869 } },
    "OnePlus 6T": { os: "android", viewport: { width: 412, height: 892 } },
    "OnePlus 7": { os: "android", viewport: { width: 412, height: 892 } },
    "OnePlus 7T": { os: "android", viewport: { width: 412, height: 914 } },
    "OnePlus 8": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus 9": { os: "android", viewport: { width: 411, height: 915 } },
    "OnePlus 9 Pro": { os: "android", viewport: { width: 412, height: 919 } },
    "OnePlus Nord": { os: "android", viewport: { width: 412, height: 914 } },
    "OnePlus Nord 2": { os: "android", viewport: { width: 412, height: 915 } },
    "OnePlus Nord CE": { os: "android", viewport: { width: 412, height: 915 } },
    "Oppo A12": { os: "android", viewport: { width: 360, height: 760 } },
    "Oppo A15": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo A54": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo A5s": { os: "android", viewport: { width: 360, height: 760 } },
    "Oppo F17": { os: "android", viewport: { width: 360, height: 800 } },
    "Oppo K10": { os: "android", viewport: { width: 360, height: 804 } },
    "Pixel 3": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 3 XL": { os: "android", viewport: { width: 412, height: 846 } },
    "Pixel 3a": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 4": { os: "android", viewport: { width: 392, height: 830 } },
    "Pixel 4 XL": { os: "android", viewport: { width: 412, height: 823 } },
    "Pixel 4a": { os: "android", viewport: { width: 393, height: 851 } },
    "Pixel 5": { os: "android", viewport: { width: 393, height: 851 } },
    "Pixel 6": { os: "android", viewport: { width: 393, height: 786 } },
    "Pixel 6 Pro": { os: "android", viewport: { width: 412, height: 892 } },
    "Pixel 7": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 7 Pro": { os: "android", viewport: { width: 412, height: 892 } },
    "Pixel 8": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 8 Pro": { os: "android", viewport: { width: 448, height: 998 } },
    "Poco M2 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "POCO X3 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "Realme 5i": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme 7i": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme 8i": { os: "android", viewport: { width: 360, height: 804 } },
    "Realme C21Y": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme C21": { os: "android", viewport: { width: 360, height: 800 } },
    "Realme GT2 Pro": { os: "android", viewport: { width: 360, height: 804 } },
    "Redmi 8": { os: "android", viewport: { width: 360, height: 760 } },
    "Redmi 9": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi 9C": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi Note 10 Pro": { os: "android", viewport: { width: 393, height: 873 } },
    "Redmi Note 8": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 8 Pro": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 9": { os: "android", viewport: { width: 393, height: 851 } },
    "Redmi Note 9 Pro Max": { os: "android", viewport: { width: 393, height: 873 } },
    "Redmi Y2": { os: "android", viewport: { width: 360, height: 720 } },
    "Tecno Spark 7": { os: "android", viewport: { width: 360, height: 800 } },
    "Vivo Y22": { os: "android", viewport: { width: 385, height: 860 } },
    "Vivo T1": { os: "android", viewport: { width: 393, height: 873 } },
    "Vivo V7": { os: "android", viewport: { width: 360, height: 720 } },
    "Vivo Y11": { os: "android", viewport: { width: 360, height: 722 } },
    "Vivo Y12": { os: "android", viewport: { width: 360, height: 722 } },
    "Vivo Y20g": { os: "android", viewport: { width: 385, height: 854 } },
    "Vivo Y50": { os: "android", viewport: { width: 393, height: 786 } },
    "Xiaomi 12 Pro": { os: "android", viewport: { width: 412, height: 915 } },
    "Xperia Z5": { os: "android", viewport: { width: 360, height: 640 } },
    "Xperia Z5 Dual": { os: "android", viewport: { width: 360, height: 640 } },
    "Zenfone 6": { os: "android", viewport: { width: 412, height: 892 } },
    "iPad 10.2 (2019)": { os: "ios", viewport: { width: 810, height: 1080 } },
    "iPad 10.2 (2020)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad 10.2 (2021)": { os: "ios", viewport: { width: 810, height: 1080 } },
    "iPad 9.7 (2017)": { os: "ios", viewport: { width: 768, height: 1024 } },
    "iPad Air (2019)": { os: "ios", viewport: { width: 834, height: 1112 } },
    "iPad Air (2020)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad Air (2022)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad mini (2019)": { os: "ios", viewport: { width: 768, height: 1024 } },
    "iPad mini (2021)": { os: "ios", viewport: { width: 744, height: 1133 } },
    "iPad Pro 11 (2021)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad Pro 11 (2022)": { os: "ios", viewport: { width: 834, height: 1194 } },
    "iPad Pro 12.9 (2018)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2020)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2021)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Pro 12.9 (2022)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPhone 11": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 11 Pro": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 11 Pro Max": { os: "ios", viewport: { width: 414, height: 896 } },
    "iPhone 12": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 12 Mini": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone 12 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 12 Pro Max": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 13": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Mini": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 13 Pro Max": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 14": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 14 Plus": { os: "ios", viewport: { width: 428, height: 926 } },
    "iPhone 14 Pro": { os: "ios", viewport: { width: 390, height: 844 } },
    "iPhone 14 Pro Max": { os: "ios", viewport: { width: 428, height: 928 } },
    "iPhone 15": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 15 Plus": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 15 Pro": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 15 Pro Max": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 6": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 6s": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 6s Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone 7": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 7 Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone 8": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone 8 Plus": { os: "ios", viewport: { width: 414, height: 736 } },
    "iPhone SE (2016)": { os: "ios", viewport: { width: 320, height: 568 } },
    "iPhone SE (2020)": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone SE (2022)": { os: "ios", viewport: { width: 375, height: 667 } },
    "iPhone X": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone XR": { os: "ios", viewport: { width: 414, height: 896 } },
    "iPhone XS": { os: "ios", viewport: { width: 375, height: 812 } },
    "iPhone XS Max": { os: "ios", viewport: { width: 414, height: 896 } },
    "Galaxy A10s": { os: "android", viewport: { width: 360, height: 640 } },
    "Galaxy A11": { os: "android", viewport: { width: 412, height: 732 } },
    "Galaxy A13": { os: "android", viewport: { width: 412, height: 732 } },
    "Galaxy A52s 5G": { os: "android", viewport: { width: 384, height: 718 } },
    "Galaxy A53 5G": { os: "android", viewport: { width: 412, height: 915 } },
    "Galaxy Tab A 10.1 (2019)": { os: "android", viewport: { width: 800, height: 1280 } },
    "Galaxy Tab S9": { os: "android", viewport: { width: 753, height: 1069 } },
    "Honor X9a 5G": { os: "android", viewport: { width: 360, height: 678 } },
    "Huawei P30 Lite": { os: "android", viewport: { width: 360, height: 647 } },
    "Huawei P50 Pro": { os: "android", viewport: { width: 412, height: 915 } },
    "iPad Pro 13 (2024)": { os: "ios", viewport: { width: 1032, height: 1376 } },
    "iPad Pro 11 (2024)": { os: "ios", viewport: { width: 834, height: 1210 } },
    "iPad Air 13 (2024)": { os: "ios", viewport: { width: 1024, height: 1366 } },
    "iPad Air 11 (2024)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPad 10.9 (2022)": { os: "ios", viewport: { width: 820, height: 1180 } },
    "iPhone 16": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 16 Plus": { os: "ios", viewport: { width: 430, height: 932 } },
    "iPhone 16 Pro": { os: "ios", viewport: { width: 402, height: 874 } },
    "iPhone 16 Pro Max": { os: "ios", viewport: { width: 440, height: 956 } },
    "Motorola Edge 40": { os: "android", viewport: { width: 412, height: 915 } },
    "Motorola Edge 30": { os: "android", viewport: { width: 432, height: 814 } },
    "Moto G22": { os: "android", viewport: { width: 412, height: 767 } },
    "Moto G54 5G": { os: "android", viewport: { width: 432, height: 810 } },
    "Moto G71 5G": { os: "android", viewport: { width: 412, height: 732 } },
    "Pixel Tablet": { os: "android", viewport: { width: 800, height: 1100 } },
    "Pixel 6a": { os: "android", viewport: { width: 412, height: 766 } },
    "Pixel 7a": { os: "android", viewport: { width: 412, height: 766 } },
    "Pixel 9": { os: "android", viewport: { width: 412, height: 924 } },
    "Pixel 9 Pro": { os: "android", viewport: { width: 412, height: 915 } },
    "Pixel 9 Pro XL": { os: "android", viewport: { width: 448, height: 998 } },
    "Redmi 9A": { os: "android", viewport: { width: 360, height: 800 } },
    "Redmi Note 13 Pro": { os: "android", viewport: { width: 412, height: 869 } },
    "Aquos Sense 5G": { os: "android", viewport: { width: 393, height: 731 } },
    "Xperia 10 IV": { os: "android", viewport: { width: 412, height: 832 } },
    "Honeywell CT40": { os: "android", viewport: { width: 360, height: 512 } },
    "Galaxy S25": { os: "android", viewport: { width: 370, height: 802 } },
    "Galaxy S25 Plus": { os: "android", viewport: { width: 393, height: 888 } },
    "Galaxy S25 Ultra": { os: "android", viewport: { width: 432, height: 941 } },
    "iPhone 17": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 17 Pro": { os: "ios", viewport: { width: 393, height: 852 } },
    "iPhone 17 Pro Max": { os: "ios", viewport: { width: 430, height: 932 } },
    "Galaxy Z Fold7": { os: "android", viewport: { width: 373, height: 873 } },
    "Galaxy Z Flip7": { os: "android", viewport: { width: 299, height: 723 } },
    "Galaxy Z Fold6": { os: "android", viewport: { width: 373, height: 873 } },
    "Galaxy Z Flip6": { os: "android", viewport: { width: 298, height: 713 } },
    "Pixel 10 Pro": { os: "android", viewport: { width: 393, height: 852 } },
    "Pixel 10 Pro XL": { os: "android", viewport: { width: 412, height: 915 } },
    "Motorola Edge 50 Pro": { os: "android", viewport: { width: 384, height: 864 } },
    "OnePlus 12": { os: "android", viewport: { width: 384, height: 884 } },
    "Nothing Phone 1": { os: "android", viewport: { width: 393, height: 853 } },
    "Nothing Phone 2": { os: "android", viewport: { width: 393, height: 878 } }
  },
  FIGMA_API: "https://api.figma.com/v1/",
  DEFAULT_FIGMA_CONFIG: {
    "depth": 1,
    "figma_config": [
      {
        "figma_file_token": "token_for_first_figma_file",
        "figma_ids": [
          "id1",
          "id2"
        ]
      }
    ]
  },
  WEB_FIGMA_CONFIG: {
    web: {
      browsers: [
        "chrome",
        "firefox",
        "safari",
        "edge"
      ]
    },
    figma: {
      "depth": 1,
      "configs": [
        {
          "figma_file_token": "<token>",
          "figma_ids": ["id-1", "id-2"],
          "screenshot_names": ["homepage", "about"]
        },
        {
          "figma_file_token": "<token>",
          "figma_ids": ["id-3", "id-4"],
          "screenshot_names": ["xyz", "abc"]
        }
      ]
    }
  },
  APP_FIGMA_CONFIG: {
    mobile: [
      {
        "name": "Pixel 8",
        "platform": ["android 14"]
      },
      {
        "name": "iPhone 15",
        "platform": ["ios 17"]
      }
    ],
    figma: {
      "depth": 1,
      "configs": [
        {
          "figma_file_token": "<token>",
          "figma_ids": ["id-1", "id-2"],
          "screenshot_names": ["homepage", "about"]
        },
        {
          "figma_file_token": "<token>",
          "figma_ids": ["id-3", "id-4"],
          "screenshot_names": ["xyz", "abc"]
        }
      ]
    }
  }
};

// src/lib/schemaValidation.ts
var ajv = new Ajv__default.default({ allErrors: true });
ajv.addFormat("web-url", {
  type: "string",
  validate: (url) => {
    try {
      new URL(url.trim());
      return true;
    } catch (error) {
      return false;
    }
  }
});
addErrors__default.default(ajv);
var ConfigSchema = {
  type: "object",
  properties: {
    web: {
      type: "object",
      properties: {
        browsers: {
          type: "array",
          items: { type: "string", enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE] },
          uniqueItems: true,
          maxItems: 4,
          errorMessage: `Invalid config; allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
        },
        viewports: {
          type: "array",
          items: {
            type: "array",
            oneOf: [
              {
                items: [{ type: "number", minimum: 320, maximum: 7680 }],
                minItems: 1,
                maxItems: 1
              },
              {
                items: [
                  { type: "number", minimum: 320, maximum: 7680 },
                  { type: "number", minimum: 320, maximum: 7680 }
                ],
                minItems: 2,
                maxItems: 2
              }
            ],
            errorMessage: "Invalid config; width/height must be >= 320 and <= 7680"
          },
          uniqueItems: true,
          maxItems: 5,
          errorMessage: "Invalid config; max unique viewports allowed - 5"
        }
      },
      required: ["browsers", "viewports"],
      additionalProperties: false
    },
    mobile: {
      type: "object",
      properties: {
        devices: {
          type: "array",
          items: {
            type: "string",
            enum: Object.keys(constants_default.SUPPORTED_MOBILE_DEVICES),
            minLength: 1,
            errorMessage: {
              enum: "Invalid config; unsupported mobile devices",
              minLength: "Invalid config; mobile device cannot be empty"
            }
          },
          uniqueItems: true,
          maxItems: 20,
          errorMessage: {
            uniqueItems: "Invalid config; duplicate mobile devices",
            maxItems: "Invalid config; max mobile devices allowed - 20"
          }
        },
        fullPage: {
          type: "boolean",
          errorMessage: "Invalid config; fullPage must be true/false"
        },
        orientation: {
          type: "string",
          enum: [constants_default.MOBILE_ORIENTATION_PORTRAIT, constants_default.MOBILE_ORIENTATION_LANDSCAPE],
          errorMessage: `Invalid config; orientation must be ${constants_default.MOBILE_ORIENTATION_PORTRAIT}/${constants_default.MOBILE_ORIENTATION_LANDSCAPE}`
        }
      },
      required: ["devices"],
      additionalProperties: false
    },
    waitForPageRender: {
      type: "number",
      minimum: 0,
      maximum: 3e5,
      errorMessage: "Invalid config; waitForPageRender must be > 0 and <= 300000"
    },
    waitForTimeout: {
      type: "number",
      minimum: 0,
      maximum: 3e4,
      errorMessage: "Invalid config; waitForTimeout must be > 0 and <= 30000"
    },
    waitForDiscovery: {
      type: "number",
      minimum: 0,
      maximum: 18e5,
      errorMessage: "Invalid config; waitForDiscovery must be > 0 and <= 1800000"
    },
    enableJavaScript: {
      type: "boolean",
      errorMessage: "Invalid config; enableJavaScript must be true/false"
    },
    cliEnableJavaScript: {
      type: "boolean",
      errorMessage: "Invalid config; cliEnableJavaScript must be true/false"
    },
    smartIgnore: {
      type: "boolean",
      errorMessage: "Invalid config; smartIgnore must be true/false"
    },
    ignoreHTTPSErrors: {
      type: "boolean",
      errorMessage: "Invalid config; ignoreHttpsError must be true/false"
    },
    scrollTime: {
      type: "number",
      minimum: 1,
      maximum: 1e3,
      errorMessage: "Invalid config; scrollTime must be > 1 and <= 1000"
    },
    allowedHostnames: {
      type: "array",
      items: {
        type: "string",
        minLength: 1,
        errorMessage: {
          minLength: "Invalid config; allowed hostname cannot be empty"
        }
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Invalid config; duplicates in allowedHostnames"
      }
    },
    allowedAssets: {
      type: "array",
      items: {
        type: "string",
        minLength: 1,
        errorMessage: {
          minLength: "Invalid config; allowedAssets cannot be empty"
        }
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Invalid config; duplicates in allowedAssets"
      }
    },
    basicAuthorization: {
      type: "object",
      properties: {
        username: {
          type: "string",
          errorMessage: "Invalid config; username is mandatory"
        },
        password: {
          type: "string",
          errorMessage: "Invalid config; password is mandatory"
        }
      }
    },
    delayedUpload: {
      type: "boolean",
      errorMessage: "Invalid config; delayedUpload must be true/false"
    },
    useGlobalCache: {
      type: "boolean",
      errorMessage: "Invalid config; useGlobalCache must be true/false"
    },
    skipBuildCreation: {
      type: "boolean",
      errorMessage: "Invalid config; skipBuildCreation must be true/false"
    },
    tunnel: {
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: ["auto", "manual"],
          errorMessage: "Invalid config; tunnel type is mandatory parameter of type string having value auto or manual"
        },
        tunnelName: {
          type: "string",
          errorMessage: "Invalid config; tunnelName should be a string value"
        },
        user: {
          type: "string",
          errorMessage: "Invalid config; user should be a string value"
        },
        key: {
          type: "string",
          errorMessage: "Invalid config; key should be a string value"
        },
        port: {
          type: "string",
          errorMessage: "Invalid config; port should be a string value"
        },
        proxyHost: {
          type: "string",
          errorMessage: "Invalid config; proxyHost should be a string value"
        },
        proxyPort: {
          type: "number",
          errorMessage: "Invalid config; proxyPort should be an int value"
        },
        proxyUser: {
          type: "string",
          errorMessage: "Invalid config; proxyUser should be a string value"
        },
        proxyPass: {
          type: "string",
          errorMessage: "Invalid config; proxyPass should be a string value"
        },
        dir: {
          type: "string",
          errorMessage: "Invalid config; dir should be a string value"
        },
        v: {
          type: "boolean",
          errorMessage: "Invalid config; v should be a boolean value"
        },
        logFile: {
          type: "string",
          errorMessage: "Invalid config; logFile should be a string value"
        },
        environment: {
          type: "string",
          enum: ["stage", "prod"],
          errorMessage: "Invalid config; environment should be a string value either stage or prod"
        }
      },
      required: ["type"],
      additionalProperties: false
    },
    userAgent: {
      type: "string",
      errorMessage: "User Agent value must be a valid string"
    },
    requestHeaders: {
      type: "array",
      items: {
        type: "object",
        minProperties: 1,
        additionalProperties: { type: "string" }
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Invalid config; duplicates in requestHeaders"
      }
    },
    dedicatedProxyURL: {
      type: "string",
      errorMessage: "Invalid config; dedicatedProxyURL must be a string"
    },
    geolocation: {
      type: "string",
      errorMessage: "Invalid config; geolocation must be a string like 'lat,lon'"
    },
    allowDuplicateSnapshotNames: {
      type: "boolean",
      errorMessage: "Invalid config; allowDuplicateSnapshotNames must be true/false"
    },
    useLambdaInternal: {
      type: "boolean",
      errorMessage: "Invalid config; useLambdaInternal must be true/false"
    },
    useRemoteDiscovery: {
      type: "boolean",
      errorMessage: "Invalid config; useRemoteDiscovery must be true/false"
    },
    useExtendedViewport: {
      type: "boolean",
      errorMessage: "Invalid config; useExtendedViewport must be true/false"
    },
    loadDomContent: {
      type: "boolean",
      errorMessage: "Invalid config; loadDomContent must be true/false"
    },
    customCSS: {
      type: "string",
      errorMessage: "Invalid config; customCSS must be a string"
    },
    approvalThreshold: {
      type: "number",
      minimum: 0,
      maximum: 100,
      errorMessage: "Invalid config; approvalThreshold must be a number"
    },
    rejectionThreshold: {
      type: "number",
      minimum: 0,
      maximum: 100,
      errorMessage: "Invalid config; rejectionThreshold must be a number"
    },
    showRenderErrors: {
      type: "boolean",
      errorMessage: "Invalid config; showRenderErrors must be true/false"
    }
  },
  anyOf: [
    { required: ["web"] },
    { required: ["mobile"] }
  ],
  additionalProperties: false
};
var WebStaticConfigSchema = {
  type: "array",
  items: {
    type: "object",
    properties: {
      name: {
        type: "string",
        minLength: 1,
        errorMessage: "name is mandatory and cannot be empty"
      },
      url: {
        type: "string",
        format: "web-url",
        errorMessage: "url is mandatory and must be a valid web URL"
      },
      waitForTimeout: {
        type: "number",
        nullable: true,
        minimum: 0,
        maximum: 3e4,
        errorMessage: "waitForTimeout must be > 0 and <= 30000"
      },
      userAgent: {
        type: "string",
        errorMessage: "User Agent value must be a valid string"
      },
      execute: {
        type: "object",
        properties: {
          beforeNavigation: {
            type: "string"
          },
          afterNavigation: {
            type: "string"
          },
          beforeSnapshot: {
            type: "string"
          }
        }
      },
      pageEvent: {
        type: "string",
        enum: ["load", "domcontentloaded"],
        errorMessage: "pageEvent can be load, domcontentloaded"
      },
      requestHeaders: {
        type: "array",
        items: {
          type: "object",
          minProperties: 1,
          additionalProperties: { type: "string" }
        },
        uniqueItems: true,
        errorMessage: {
          uniqueItems: "Invalid config; duplicates in requestHeaders"
        }
      }
    },
    required: ["name", "url"],
    additionalProperties: false
  },
  uniqueItems: true
};
var SnapshotSchema = {
  type: "object",
  properties: {
    name: {
      type: "string",
      minLength: 1,
      maxLength: 255,
      pattern: "^.*\\S.*$",
      errorMessage: "Invalid snapshot: name is mandatory, cannot be empty, and must not exceed 255 characters."
    },
    url: {
      type: "string",
      format: "web-url",
      errorMessage: "Invalid snapshot; url is mandatory and must be a valid web URL"
    },
    dom: {
      type: "object"
    },
    options: {
      type: "object",
      properties: {
        element: {
          type: "object",
          properties: {
            id: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element id cannot be empty or have semicolon"
            },
            class: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element class cannot be empty or have semicolon"
            },
            cssSelector: {
              type: "string",
              pattern: "^[^;]*$",
              errorMessage: "Invalid snapshot options; element cssSelector cannot be empty or have semicolon"
            },
            xpath: {
              type: "string",
              errorMessage: "Invalid snapshot options; element xpath cannot be empty"
            }
          }
        },
        ignoreDOM: {
          type: "object",
          properties: {
            id: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM id cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM id array must have unique items"
            },
            class: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM class cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM class array must have unique items"
            },
            cssSelector: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; ignoreDOM cssSelector cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM cssSelector array must have unique items"
            },
            xpath: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM xpath array must have unique and non-empty items"
            },
            coordinates: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; ignoreDOM coordinates array must have unique and non-empty items"
            }
          }
        },
        selectDOM: {
          type: "object",
          properties: {
            id: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM id cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM id array must have unique items"
            },
            class: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM class cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM class array must have unique items"
            },
            cssSelector: {
              type: "array",
              items: { type: "string", minLength: 1, pattern: "^[^;]*$", errorMessage: "Invalid snapshot options; selectDOM cssSelector cannot be empty or have semicolon" },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM cssSelector array must have unique items"
            },
            xpath: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM xpath array must have unique and non-empty items"
            },
            coordinates: {
              type: "array",
              items: { type: "string", minLength: 1 },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; selectDOM coordinates array must have unique and non-empty items"
            }
          }
        },
        ignoreType: {
          type: "array",
          items: {
            type: "string",
            minLength: 1,
            enum: ["default", "layout", "images", "text", "colors", "dimensions", "position", "structure"],
            errorMessage: "Invalid snapshot options;ignoreType cannot be empty"
          },
          uniqueItems: true,
          errorMessage: "Invalid snapshot options; ignoreType must be an array of unique values from default, layout, images, text, colors, dimensions, position, structure"
        },
        web: {
          type: "object",
          properties: {
            browsers: {
              type: "array",
              items: {
                type: "string",
                enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE],
                minLength: 1
              },
              uniqueItems: true,
              errorMessage: `Invalid snapshot options; allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
            },
            viewports: {
              type: "array",
              items: {
                type: "array",
                items: {
                  type: "number",
                  minimum: 1
                },
                minItems: 1,
                maxItems: 2,
                errorMessage: "Invalid snapshot options; each viewport array must contain either a single width or a width and height tuple with positive values."
              },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; viewports must be an array of unique arrays."
            }
          },
          required: ["viewports"],
          errorMessage: "Invalid snapshot options; web must include viewports property."
        },
        mobile: {
          type: "object",
          properties: {
            devices: {
              type: "array",
              items: {
                type: "string",
                enum: Object.keys(constants_default.SUPPORTED_MOBILE_DEVICES),
                minLength: 1
              },
              uniqueItems: true,
              errorMessage: "Invalid snapshot options; devices must be an array of unique supported mobile devices."
            },
            fullPage: {
              type: "boolean",
              errorMessage: "Invalid snapshot options; fullPage must be a boolean."
            },
            orientation: {
              type: "string",
              enum: [constants_default.MOBILE_ORIENTATION_PORTRAIT, constants_default.MOBILE_ORIENTATION_LANDSCAPE],
              errorMessage: "Invalid snapshot options; orientation must be either 'portrait' or 'landscape'."
            }
          },
          required: ["devices"],
          errorMessage: "Invalid snapshot options; mobile must include devices property."
        },
        loadDomContent: {
          type: "boolean",
          errorMessage: "Invalid snapshot options; loadDomContent must be a boolean"
        },
        sessionId: {
          type: "string",
          errorMessage: "Invalid snapshot options; sessionId must be a string"
        },
        contextId: {
          type: "string",
          errorMessage: "Invalid snapshot options; contextId must be a string"
        },
        sync: {
          type: "boolean",
          errorMessage: "Invalid snapshot options; sync must be a boolean"
        },
        timeout: {
          type: "number",
          errorMessage: "Invalid snapshot options; timeout must be a number"
        },
        useExtendedViewport: {
          type: "boolean",
          errorMessage: "Invalid snapshot options; useExtendedViewport must be a boolean"
        },
        approvalThreshold: {
          type: "number",
          minimum: 0,
          maximum: 100,
          errorMessage: "Invalid snapshot options; approvalThreshold must be a number between 0 and 100"
        },
        rejectionThreshold: {
          type: "number",
          minimum: 0,
          maximum: 100,
          errorMessage: "Invalid snapshot options; rejectionThreshold must be a number between 0 and 100"
        },
        customCookies: {
          type: "array",
          items: {
            type: "object",
            minProperties: 1
          },
          errorMessage: "Invalid snapshot options; customCookies must be an array of objects with string properties"
        },
        customCSS: {
          type: "string",
          errorMessage: "Invalid snapshot options; customCSS must be a string"
        }
      },
      additionalProperties: false
    }
  },
  required: ["name", "url", "dom"],
  additionalProperties: false,
  errorMessage: "Invalid snapshot"
};
var FigmaDesignConfigSchema = {
  type: "object",
  properties: {
    depth: {
      type: "integer",
      minimum: 1,
      errorMessage: "Depth must be an integer and greater than 0"
    },
    figma_config: {
      type: "array",
      items: {
        type: "object",
        properties: {
          figma_file_token: {
            type: "string",
            minLength: 1,
            errorMessage: "figma_file_token is mandatory and cannot be empty"
          },
          figma_ids: {
            type: "array",
            items: {
              type: "string",
              minLength: 1,
              errorMessage: "Each ID in figma_ids must be a non-empty string"
            },
            minItems: 1,
            uniqueItems: true,
            errorMessage: {
              type: "figma_ids must be an array of strings",
              minItems: "figma_ids cannot be empty",
              uniqueItems: "figma_ids must contain unique values"
            }
          }
        },
        required: ["figma_file_token"],
        additionalProperties: false
      },
      uniqueItems: true,
      errorMessage: {
        uniqueItems: "Each entry in the Figma design configuration must be unique"
      }
    }
  },
  required: ["figma_config"],
  additionalProperties: false
};
var FigmaWebConfigSchema = {
  type: "object",
  "properties": {
    "web": {
      "type": "object",
      "properties": {
        browsers: {
          type: "array",
          items: { type: "string", enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE] },
          uniqueItems: true,
          maxItems: 4,
          errorMessage: `allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
        },
        "viewports": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "minItems": 1
          }
        }
      },
      "required": ["browsers"]
    },
    "figma": {
      "type": "object",
      "properties": {
        depth: {
          type: "integer",
          minimum: 1,
          errorMessage: "Depth must be an integer and greater than 0"
        },
        "configs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "figma_file_token": {
                "type": "string",
                minLength: 1,
                errorMessage: "figma_file_token is mandatory and cannot be empty"
              },
              "figma_ids": {
                "type": "array",
                "items": {
                  "type": "string",
                  minLength: 1,
                  errorMessage: "Each ID in figma_ids must be a non-empty string"
                },
                minItems: 1,
                uniqueItems: true,
                errorMessage: {
                  type: "figma_ids must be an array of strings",
                  minItems: "figma_ids cannot be empty",
                  uniqueItems: "figma_ids must contain unique values"
                }
              },
              "screenshot_names": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                uniqueItems: false
              }
            },
            "required": ["figma_file_token", "figma_ids"]
          },
          uniqueItems: true,
          errorMessage: {
            uniqueItems: "Each entry in the figma configs must be unique"
          }
        }
      },
      "required": ["configs"]
    },
    smartIgnore: {
      type: "boolean",
      errorMessage: "Invalid config; smartIgnore must be true/false"
    }
  },
  "required": ["web", "figma"],
  additionalProperties: false
};
var FigmaAppConfigSchema = {
  type: "object",
  "properties": {
    "web": {
      "type": "object",
      "properties": {
        browsers: {
          type: "array",
          items: { type: "string", enum: [constants_default.CHROME, constants_default.FIREFOX, constants_default.SAFARI, constants_default.EDGE] },
          uniqueItems: true,
          maxItems: 4,
          errorMessage: `allowed browsers - ${constants_default.CHROME}, ${constants_default.FIREFOX}, ${constants_default.SAFARI}, ${constants_default.EDGE}`
        },
        "viewports": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "integer",
              "minimum": 1
            },
            "minItems": 1
          }
        }
      },
      "required": ["browsers"]
    },
    "mobile": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          name: {
            type: "string",
            minLength: 1,
            enum: Object.keys(constants_default.SUPPORTED_MOBILE_DEVICES),
            errorMessage: "unsupported mobile device name"
          },
          "platform": {
            "type": "array",
            "items": {
              "type": "string"
            },
            uniqueItems: true
          },
          orientation: {
            type: "string",
            enum: [constants_default.MOBILE_ORIENTATION_PORTRAIT, constants_default.MOBILE_ORIENTATION_LANDSCAPE],
            errorMessage: `Invalid config; orientation must be ${constants_default.MOBILE_ORIENTATION_PORTRAIT}/${constants_default.MOBILE_ORIENTATION_LANDSCAPE}`
          }
        },
        "required": ["name"]
      },
      uniqueItems: true
    },
    "figma": {
      "type": "object",
      "properties": {
        depth: {
          type: "integer",
          minimum: 1,
          errorMessage: "Depth must be an integer and greater than 0"
        },
        "configs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "figma_file_token": {
                "type": "string",
                minLength: 1,
                errorMessage: "figma_file_token is mandatory and cannot be empty"
              },
              "figma_ids": {
                "type": "array",
                "items": {
                  "type": "string",
                  minLength: 1,
                  errorMessage: "Each ID in figma_ids must be a non-empty string"
                },
                minItems: 1,
                uniqueItems: true,
                errorMessage: {
                  type: "figma_ids must be an array of strings",
                  minItems: "figma_ids cannot be empty",
                  uniqueItems: "figma_ids must contain unique values"
                }
              },
              "screenshot_names": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                uniqueItems: false
              }
            },
            "required": ["figma_file_token", "figma_ids"]
          },
          uniqueItems: true,
          errorMessage: {
            uniqueItems: "Each entry in the figma configs must be unique"
          }
        }
      },
      "required": ["configs"]
    },
    smartIgnore: {
      type: "boolean",
      errorMessage: "Invalid config; smartIgnore must be true/false"
    }
  },
  "required": ["mobile", "figma"],
  additionalProperties: false
};
var validateConfig = ajv.compile(ConfigSchema);
var validateWebStaticConfig = ajv.compile(WebStaticConfigSchema);
var validateSnapshot = ajv.compile(SnapshotSchema);
var validateFigmaDesignConfig = ajv.compile(FigmaDesignConfigSchema);
var validateWebFigmaConfig = ajv.compile(FigmaWebConfigSchema);
var validateAppFigmaConfig = ajv.compile(FigmaAppConfigSchema);
var validateConfigForScheduled = (config) => {
  validateConfigForScheduled.errors = null;
  if (!validateConfig(config)) {
    let errors = validateConfig.errors || [];
    errors = errors.filter((error) => {
      const message = error.message || "";
      return !message.includes("max unique viewports allowed - 5");
    });
    if (config.web && config.web.viewports && Array.isArray(config.web.viewports)) {
      if (config.web.viewports.length > 8) {
        errors.push({
          message: "Invalid config; max unique viewports allowed - 8 (scheduled build)",
          keyword: "maxItems",
          instancePath: "/web/viewports",
          schemaPath: "#/properties/web/properties/viewports/maxItems"
        });
      }
    }
    if (errors.length > 0) {
      validateConfigForScheduled.errors = errors;
      return false;
    }
  }
  return true;
};
validateConfigForScheduled.errors = null;
var util = __require("util");
var lambdaTunnel = __require("@lambdatest/node-tunnel");
util$1.promisify(setTimeout);
var tunnelInstance;
function delDir(dir) {
  if (fs6__default.default.existsSync(dir)) {
    fs6__default.default.rmSync(dir, { recursive: true });
  }
}
function scrollToBottomAndBackToTop({
  frequency = 100,
  timing = 8,
  remoteWindow = window
} = {}) {
  return new Promise((resolve) => {
    let scrolls = 1;
    let scrollLength = remoteWindow.document.body.scrollHeight / frequency;
    (function scroll() {
      let scrollBy = scrollLength * scrolls;
      remoteWindow.setTimeout(() => {
        remoteWindow.scrollTo(0, scrollBy);
        if (scrolls < frequency) {
          scrolls += 1;
          scroll();
        }
        if (scrolls === frequency) {
          remoteWindow.setTimeout(() => {
            remoteWindow.scrollTo(0, 0);
            resolve();
          }, timing);
        }
      }, timing);
    })();
  });
}
function launchBrowsers(ctx) {
  return __async(this, null, function* () {
    var _a;
    let browsers = {};
    const isHeadless = ((_a = process.env.HEADLESS) == null ? void 0 : _a.toLowerCase()) === "false" ? false : true;
    let launchOptions = { headless: isHeadless };
    if (ctx.config.web) {
      for (const browser of ctx.config.web.browsers) {
        switch (browser) {
          case constants_default.CHROME:
            browsers[constants_default.CHROME] = yield test.chromium.launch(launchOptions);
            break;
          case constants_default.SAFARI:
            browsers[constants_default.SAFARI] = yield test.webkit.launch(launchOptions);
            break;
          case constants_default.FIREFOX:
            browsers[constants_default.FIREFOX] = yield test.firefox.launch(launchOptions);
            break;
          case constants_default.EDGE:
            launchOptions.args = ["--headless=new"];
            browsers[constants_default.EDGE] = yield test.chromium.launch(__spreadValues({ channel: constants_default.EDGE_CHANNEL }, launchOptions));
            break;
        }
      }
    }
    if (ctx.config.mobile) {
      for (const device of ctx.config.mobile.devices) {
        if (constants_default.SUPPORTED_MOBILE_DEVICES[device].os === "android" && !browsers[constants_default.CHROME])
          browsers[constants_default.CHROME] = yield test.chromium.launch(launchOptions);
        else if (constants_default.SUPPORTED_MOBILE_DEVICES[device].os === "ios" && !browsers[constants_default.SAFARI])
          browsers[constants_default.SAFARI] = yield test.webkit.launch(launchOptions);
      }
    }
    return browsers;
  });
}
function closeBrowsers(browsers) {
  return __async(this, null, function* () {
    var _a;
    for (const browserName of Object.keys(browsers))
      yield (_a = browsers[browserName]) == null ? void 0 : _a.close();
  });
}
function getWebRenderViewports(ctx) {
  let webRenderViewports = [];
  if (ctx.config.web) {
    for (const viewport of ctx.config.web.viewports) {
      webRenderViewports.push({
        viewport,
        viewportString: `${viewport.width}${viewport.height ? "x" + viewport.height : ""}`,
        fullPage: viewport.height ? false : true,
        device: false
      });
    }
  }
  return webRenderViewports;
}
function getWebRenderViewportsForOptions(options) {
  let webRenderViewports = [];
  if (options.web && Array.isArray(options.web.viewports)) {
    for (const viewport of options.web.viewports) {
      if (Array.isArray(viewport) && viewport.length > 0) {
        let viewportObj = {
          width: viewport[0]
        };
        if (viewport.length > 1) {
          viewportObj.height = viewport[1];
        }
        webRenderViewports.push({
          viewport: viewportObj,
          viewportString: `${viewport[0]}${viewport[1] ? "x" + viewport[1] : ""}`,
          fullPage: viewport.length === 1,
          device: false
        });
      }
    }
  }
  return webRenderViewports;
}
function getMobileRenderViewports(ctx) {
  var _a;
  let mobileRenderViewports = {};
  mobileRenderViewports[constants_default.MOBILE_OS_IOS] = [];
  mobileRenderViewports[constants_default.MOBILE_OS_ANDROID] = [];
  if (ctx.config.mobile) {
    for (const device of ctx.config.mobile.devices) {
      let os = constants_default.SUPPORTED_MOBILE_DEVICES[device].os;
      let { width, height } = constants_default.SUPPORTED_MOBILE_DEVICES[device].viewport;
      let portrait = ctx.config.mobile.orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT ? true : false;
      (_a = mobileRenderViewports[os]) == null ? void 0 : _a.push({
        viewport: { width: portrait ? width : height, height: portrait ? height : width },
        viewportString: `${device} (${ctx.config.mobile.orientation})`,
        fullPage: ctx.config.mobile.fullPage,
        device: true,
        os
      });
    }
  }
  return mobileRenderViewports;
}
function getMobileRenderViewportsForOptions(options) {
  var _a;
  let mobileRenderViewports = {};
  mobileRenderViewports[constants_default.MOBILE_OS_IOS] = [];
  mobileRenderViewports[constants_default.MOBILE_OS_ANDROID] = [];
  if (options.mobile) {
    for (const device of options.mobile.devices) {
      let os = constants_default.SUPPORTED_MOBILE_DEVICES[device].os;
      let { width, height } = constants_default.SUPPORTED_MOBILE_DEVICES[device].viewport;
      let orientation = options.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT;
      let portrait = orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT;
      let fullPage;
      if (options.mobile.fullPage === void 0 || options.mobile.fullPage) {
        fullPage = true;
      } else {
        fullPage = false;
      }
      (_a = mobileRenderViewports[os]) == null ? void 0 : _a.push({
        viewport: { width: portrait ? width : height, height: portrait ? height : width },
        viewportString: `${device} (${orientation})`,
        fullPage,
        device: true,
        os
      });
    }
  }
  return mobileRenderViewports;
}
function getRenderViewports(ctx) {
  let mobileRenderViewports = getMobileRenderViewports(ctx);
  let webRenderViewports = getWebRenderViewports(ctx);
  return [
    ...webRenderViewports,
    ...mobileRenderViewports[constants_default.MOBILE_OS_IOS],
    ...mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]
  ];
}
function getRenderViewportsForOptions(options) {
  let mobileRenderViewports = getMobileRenderViewportsForOptions(options);
  let webRenderViewports = getWebRenderViewportsForOptions(options);
  return [
    ...webRenderViewports,
    ...mobileRenderViewports[constants_default.MOBILE_OS_IOS],
    ...mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]
  ];
}
function startPolling(ctx, build_id, baseline, projectToken) {
  return __async(this, null, function* () {
    if (build_id) {
      ctx.log.info(`Fetching results for buildId ${build_id} in progress....`);
    } else if (ctx.build && ctx.build.id) {
      ctx.log.info(`Fetching results for buildId ${ctx.build.id} in progress....`);
    }
    const intervalId = setInterval(() => __async(this, null, function* () {
      try {
        let resp;
        if (build_id) {
          resp = yield ctx.client.getScreenshotData(build_id, baseline, ctx.log, projectToken, "");
        } else if (ctx.build && ctx.build.id) {
          resp = yield ctx.client.getScreenshotData(ctx.build.id, ctx.build.baseline, ctx.log, "", "");
        } else {
          return;
        }
        if (!resp.build) {
          ctx.log.info("Error: Build data is null.");
          clearInterval(intervalId);
          return;
        }
        let fileName = `${resp.build.build_id}.json`;
        if (ctx.options.fetchResults && ctx.options.fetchResultsFileName && ctx.build && ctx.build.id && resp.build.build_id === ctx.build.id) {
          fileName = `${ctx.options.fetchResultsFileName}`;
        }
        fs6__default.default.writeFileSync(`${fileName}`, JSON.stringify(resp, null, 2));
        ctx.log.debug(`Updated results in ${fileName}`);
        if (resp.build.build_status_ind === constants_default.BUILD_COMPLETE || resp.build.build_status_ind === constants_default.BUILD_ERROR) {
          clearInterval(intervalId);
          ctx.log.info(`Fetching results completed. Final results written to ${fileName}`);
          let totalScreenshotsWithMismatches = 0;
          let totalVariantsWithMismatches = 0;
          const totalScreenshots = Object.keys(resp.screenshots || {}).length;
          let totalVariants = 0;
          for (const [screenshot, variants] of Object.entries(resp.screenshots || {})) {
            let screenshotHasMismatch = false;
            let variantMismatchCount = 0;
            totalVariants += variants.length;
            for (const variant of variants) {
              if (variant.mismatch_percentage > 0) {
                screenshotHasMismatch = true;
                variantMismatchCount++;
              }
            }
            if (screenshotHasMismatch) {
              totalScreenshotsWithMismatches++;
              totalVariantsWithMismatches += variantMismatchCount;
            }
          }
          ctx.log.info(
            chalk__default.default.green.bold(
              `
Summary of Mismatches for buildId: ${build_id}
${chalk__default.default.yellow("Total Variants with Mismatches:")} ${chalk__default.default.white(totalVariantsWithMismatches)} out of ${chalk__default.default.white(totalVariants)}
${chalk__default.default.yellow("Total Screenshots with Mismatches:")} ${chalk__default.default.white(totalScreenshotsWithMismatches)} out of ${chalk__default.default.white(totalScreenshots)}
${chalk__default.default.yellow("Branch Name:")} ${chalk__default.default.white(resp.build.branch)}
${chalk__default.default.yellow("Project Name:")} ${chalk__default.default.white(resp.project.name)}
${chalk__default.default.yellow("Build ID:")} ${chalk__default.default.white(resp.build.build_id)}
`
            )
          );
        }
      } catch (error) {
        if (error.message.includes("ENOTFOUND")) {
          ctx.log.error("Error: Network error occurred while fetching build results. Please check your connection and try again.");
          clearInterval(intervalId);
        } else {
          ctx.log.error(`Error fetching screenshot data: ${error.message}`);
        }
        clearInterval(intervalId);
      }
    }), 5e3);
  });
}
var pingIntervalId = null;
function startPingPolling(ctx) {
  return __async(this, null, function* () {
    try {
      ctx.log.debug("Sending initial ping to server...");
      yield ctx.client.ping(ctx.build.id, ctx.log);
      ctx.log.debug("Initial ping sent successfully.");
    } catch (error) {
      ctx.log.error(`Error during initial ping: ${error.message}`);
    }
    let sourceCommand = ctx.sourceCommand ? ctx.sourceCommand : "";
    pingIntervalId = setInterval(() => __async(this, null, function* () {
      try {
        ctx.log.debug("Sending ping to server... " + sourceCommand);
        yield ctx.client.ping(ctx.build.id, ctx.log);
        ctx.log.debug("Ping sent successfully. " + sourceCommand);
      } catch (error) {
        ctx.log.error(`Error during ping polling: ${error.message}`);
      }
    }), 10 * 60 * 1e3);
  });
}
function startTunnelBinary(ctx) {
  return __async(this, null, function* () {
    var _a;
    let tunnelConfig = ctx.config.tunnel;
    let tunnelArguments = {
      user: tunnelConfig.user || ctx.env.LT_USERNAME || "",
      key: tunnelConfig.key || ctx.env.LT_ACCESS_KEY || ""
    };
    ctx.config.tunnel.user = (tunnelConfig == null ? void 0 : tunnelConfig.user) || ctx.env.LT_USERNAME || "";
    ctx.config.tunnel.key = (tunnelConfig == null ? void 0 : tunnelConfig.key) || ctx.env.LT_ACCESS_KEY || "";
    if (tunnelConfig.port) {
      tunnelArguments.port = tunnelConfig.port;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.proxyHost) {
      tunnelArguments.proxyHost = tunnelConfig.proxyHost;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.proxyPort) {
      tunnelArguments.proxyPort = tunnelConfig.proxyPort;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.proxyUser) {
      tunnelArguments.proxyUser = tunnelConfig.proxyUser;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.proxyPass) {
      tunnelArguments.proxyPass = tunnelConfig.proxyPass;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.dir) {
      tunnelArguments.dir = tunnelConfig.dir;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.v) {
      tunnelArguments.v = tunnelConfig.v;
      tunnelArguments.logLevel = "debug";
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.logFile) {
      tunnelArguments.logFile = tunnelConfig.logFile;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.tunnelName) {
      tunnelArguments.tunnelName = tunnelConfig.tunnelName;
    } else {
      const randomNumber = Math.floor(1e6 + Math.random() * 9e6);
      let randomTunnelName = `smartui-cli-Node-tunnel-${randomNumber}`;
      tunnelArguments.tunnelName = randomTunnelName;
      ctx.config.tunnel.tunnelName = randomTunnelName;
    }
    if (tunnelConfig == null ? void 0 : tunnelConfig.environment) {
      tunnelArguments.environment = tunnelConfig.environment;
    }
    ctx.log.debug(`tunnel config ${JSON.stringify(tunnelArguments)}`);
    if (((_a = ctx.config.tunnel) == null ? void 0 : _a.type) === "auto") {
      tunnelInstance = new lambdaTunnel();
      const istunnelStarted = yield tunnelInstance.start(tunnelArguments);
      ctx.log.debug("Tunnel is started Successfully with status " + istunnelStarted);
      const tunnelRunningStatus = yield tunnelInstance.isRunning();
      ctx.log.debug("Running status of tunnel after start ? " + tunnelRunningStatus);
    }
  });
}
var isTunnelPolling = null;
function startPollingForTunnel(ctx, build_id, baseline, projectToken, buildName) {
  return __async(this, null, function* () {
    if (isTunnelPolling) {
      ctx.log.debug("Tunnel polling is already active. Skipping for build_id: " + build_id);
      return;
    }
    const intervalId = setInterval(() => __async(this, null, function* () {
      try {
        let resp;
        if (build_id) {
          resp = yield ctx.client.getScreenshotData(build_id, baseline, ctx.log, projectToken, buildName);
        } else if (ctx.build && ctx.build.id) {
          resp = yield ctx.client.getScreenshotData(ctx.build.id, ctx.build.baseline, ctx.log, "", "");
        } else {
          ctx.log.debug("No build information available for polling tunnel status.");
          clearInterval(intervalId);
          yield stopTunnelHelper(ctx);
          return;
        }
        ctx.log.debug(" resp from polling for tunnel status: " + JSON.stringify(resp));
        if (!resp.build) {
          ctx.log.info("Error: Build data is null.");
          clearInterval(intervalId);
          yield stopTunnelHelper(ctx);
          return;
        }
        if (resp.build.build_status_ind === constants_default.BUILD_COMPLETE || resp.build.build_status_ind === constants_default.BUILD_ERROR) {
          clearInterval(intervalId);
          yield stopTunnelHelper(ctx);
          return;
        }
      } catch (error) {
        if (error == null ? void 0 : error.message.includes("ENOTFOUND")) {
          ctx.log.error("Error: Network error occurred while fetching build status while polling. Please check your connection and try again.");
          clearInterval(intervalId);
        } else {
          ctx.log.debug(util.inspect(error, { showHidden: false, depth: null }));
          ctx.log.error(`Error fetching build status while polling: ${JSON.stringify(error)}`);
        }
        clearInterval(intervalId);
      }
    }), 5e3);
    isTunnelPolling = intervalId;
  });
}
function stopTunnelHelper(ctx) {
  return __async(this, null, function* () {
    ctx.log.debug("stop-tunnel:: Stopping the tunnel now");
    const tunnelRunningStatus = yield tunnelInstance == null ? void 0 : tunnelInstance.isRunning();
    ctx.log.debug("stop-tunnel:: Running status of tunnel before stopping ? " + tunnelRunningStatus);
    const status = yield tunnelInstance.stop();
    ctx.log.debug("stop-tunnel:: Tunnel is Stopped ? " + status);
  });
}
function calculateVariantCount(config) {
  let variantCount = 0;
  if (config.web) {
    const browsers = config.web.browsers || [];
    const viewports = config.web.viewports || [];
    variantCount += browsers.length * viewports.length;
  }
  if (config.mobile) {
    const devices = config.mobile.devices || [];
    variantCount += devices.length;
  }
  return variantCount;
}
function calculateVariantCountFromSnapshot(snapshot, globalConfig) {
  var _a, _b;
  let variantCount = 0;
  if ((_a = snapshot.options) == null ? void 0 : _a.web) {
    const browsers = snapshot.options.web.browsers || [];
    const viewports = snapshot.options.web.viewports || [];
    variantCount += browsers.length * viewports.length;
  }
  if ((_b = snapshot.options) == null ? void 0 : _b.mobile) {
    const devices = snapshot.options.mobile.devices || [];
    variantCount += devices.length;
  }
  if (variantCount === 0 && globalConfig) {
    variantCount = calculateVariantCount(globalConfig);
  }
  return variantCount;
}
function startPdfPolling(ctx) {
  console.log(chalk__default.default.yellow("\nFetching PDF test results..."));
  ctx.log.debug(`Starting fetching results for build: ${ctx.build.id || ctx.build.name}`);
  if (!ctx.build.id && !ctx.build.name) {
    ctx.log.error(chalk__default.default.red("Error: Build information not found for fetching results"));
    return;
  }
  if (!ctx.env.LT_USERNAME || !ctx.env.LT_ACCESS_KEY) {
    console.log(chalk__default.default.red("Error: LT_USERNAME and LT_ACCESS_KEY environment variables are required for fetching results"));
    return;
  }
  let attempts = 0;
  const maxAttempts = 60;
  console.log(chalk__default.default.yellow("Waiting for results..."));
  const interval = setInterval(() => __async(this, null, function* () {
    var _a;
    attempts++;
    try {
      const response = yield ctx.client.fetchPdfResults(ctx);
      if (response.screenshots && ((_a = response.build) == null ? void 0 : _a.build_status) !== constants_default.BUILD_RUNNING) {
        clearInterval(interval);
        const pdfGroups = groupScreenshotsByPdf(response.screenshots);
        const pdfsWithMismatches = countPdfsWithMismatches(pdfGroups);
        const pagesWithMismatches = countPagesWithMismatches(response.screenshots);
        console.log(chalk__default.default.green("\n\u2713 PDF Test Results:"));
        console.log(chalk__default.default.green(`Build Name: ${response.build.name}`));
        console.log(chalk__default.default.green(`Project Name: ${response.project.name}`));
        console.log(chalk__default.default.green(`Total PDFs: ${Object.keys(pdfGroups).length}`));
        console.log(chalk__default.default.green(`Total Pages: ${response.screenshots.length}`));
        if (pdfsWithMismatches > 0 || pagesWithMismatches > 0) {
          console.log(chalk__default.default.yellow(`${pdfsWithMismatches} PDFs and ${pagesWithMismatches} Pages in build ${response.build.name} have changes present.`));
        } else {
          console.log(chalk__default.default.green("All PDFs match the baseline."));
        }
        Object.entries(pdfGroups).forEach(([pdfName, pages]) => {
          const hasMismatch = pages.some((page) => page.mismatch_percentage > 0);
          const statusColor = hasMismatch ? chalk__default.default.yellow : chalk__default.default.green;
          console.log(statusColor(`
\u{1F4C4} ${pdfName} (${pages.length} pages)`));
          pages.forEach((page) => {
            const pageStatusColor = page.mismatch_percentage > 0 ? chalk__default.default.yellow : chalk__default.default.green;
            console.log(pageStatusColor(`  - Page ${getPageNumber(page.screenshot_name)}: ${page.status} (Mismatch: ${page.mismatch_percentage}%)`));
          });
        });
        const formattedResults = {
          status: "success",
          data: {
            buildId: response.build.id,
            buildName: response.build.name,
            projectName: response.project.name,
            buildStatus: response.build.build_satus,
            pdfs: formatPdfsForOutput(pdfGroups)
          }
        };
        if (ctx.options.fetchResults && ctx.options.fetchResultsFileName) {
          const filename = ctx.options.fetchResultsFileName !== "" ? ctx.options.fetchResultsFileName : "pdf-results.json";
          fs6__default.default.writeFileSync(filename, JSON.stringify(formattedResults, null, 2));
          console.log(chalk__default.default.green(`
Results saved to ${filename}`));
        }
        return;
      }
      if (attempts >= maxAttempts) {
        clearInterval(interval);
        console.log(chalk__default.default.red("\nTimeout: Could not fetch PDF results after 5 minutes"));
        return;
      }
    } catch (error) {
      ctx.log.debug(`Error during polling: ${error.message}`);
      if (attempts >= maxAttempts) {
        clearInterval(interval);
        console.log(chalk__default.default.red("\nTimeout: Could not fetch PDF results after 5 minutes"));
        if (error.response && error.response.data) {
          console.log(chalk__default.default.red(`Error details: ${JSON.stringify(error.response.data)}`));
        } else {
          console.log(chalk__default.default.red(`Error details: ${error.message}`));
        }
        return;
      }
      process.stdout.write(chalk__default.default.yellow("."));
    }
  }), 1e4);
}
function groupScreenshotsByPdf(screenshots) {
  const pdfGroups = {};
  screenshots.forEach((screenshot) => {
    const pdfName = screenshot.screenshot_name.split("#")[0];
    if (!pdfGroups[pdfName]) {
      pdfGroups[pdfName] = [];
    }
    pdfGroups[pdfName].push(screenshot);
  });
  return pdfGroups;
}
function countPdfsWithMismatches(pdfGroups) {
  let count = 0;
  Object.values(pdfGroups).forEach((pages) => {
    if (pages.some((page) => page.mismatch_percentage > 0)) {
      count++;
    }
  });
  return count;
}
function countPagesWithMismatches(screenshots) {
  return screenshots.filter((screenshot) => screenshot.mismatch_percentage > 0).length;
}
function formatPdfsForOutput(pdfGroups) {
  return Object.entries(pdfGroups).map(([pdfName, pages]) => {
    return {
      pdfName,
      pageCount: pages.length,
      pages: pages.map((page) => ({
        pageNumber: getPageNumber(page.screenshot_name),
        screenshotId: page.captured_image_id,
        mismatchPercentage: page.mismatch_percentage,
        status: page.status,
        screenshotUrl: page.shareable_link
      }))
    };
  });
}
function getPageNumber(screenshotName) {
  const parts = screenshotName.split("#");
  return parts.length > 1 ? parts[1] : "1";
}
function validateCoordinates(coordString, pageHeight, pageWidth, snapshotName) {
  const coords = coordString.split(",").map(Number);
  if (coords.length !== 4) {
    return {
      valid: false,
      error: `for snapshot ${snapshotName}, invalid coordinates format: ${coordString}. Expected: top,bottom,left,right`
    };
  }
  const [top, bottom, left, right] = coords;
  if (coords.some(isNaN)) {
    return {
      valid: false,
      error: `for snapshot ${snapshotName}, invalid coordinate values: ${coordString}. All values must be numbers`
    };
  }
  if (top < 0 || left < 0 || bottom < 0 || right < 0) {
    return {
      valid: false,
      error: `for snapshot ${snapshotName}, invalid coordinate bounds: ${coordString}. top,left,bottom,right must be >= 0`
    };
  }
  if (top >= bottom) {
    return {
      valid: false,
      error: `for snapshot ${snapshotName}, invalid coordinate bounds: ${coordString}. top must be < bottom`
    };
  }
  if (left >= right) {
    return {
      valid: false,
      error: `for snapshot ${snapshotName}, invalid coordinate bounds: ${coordString}. left must be < right`
    };
  }
  if (bottom > pageHeight) {
    return {
      valid: false,
      error: `for snapshot ${snapshotName}, coordinates exceed viewport bounds: ${coordString}. bottom (${bottom}) exceeds viewport height (${pageHeight})`
    };
  }
  if (right > pageWidth) {
    return {
      valid: false,
      error: `for snapshot ${snapshotName}, coordinates exceed viewport bounds: ${coordString}. right (${right}) exceeds viewport width (${pageWidth})`
    };
  }
  return {
    valid: true,
    coords: { top, bottom, left, right }
  };
}
function createBasicAuthToken(username, accessKey) {
  const credentials = `${username}:${accessKey}`;
  return Buffer.from(credentials).toString("base64");
}
function listenToSmartUISSE(baseURL, accessToken, ctx, onEvent) {
  return __async(this, null, function* () {
    var _a;
    const url = `${baseURL}/api/v1/sse/smartui`;
    const abortController = new AbortController();
    try {
      const cookieKey = baseURL === "https://server-events.lambdatest.com" ? "accessToken" : "stageAccessToken";
      const response = yield fetch(url, {
        method: "GET",
        headers: {
          "Accept": "text/event-stream",
          "Cache-Control": "no-cache",
          "Cookie": `${cookieKey}=Basic ${accessToken}`
        },
        signal: abortController.signal
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      onEvent == null ? void 0 : onEvent("open", { status: "connected" });
      const reader = (_a = response.body) == null ? void 0 : _a.getReader();
      if (!reader) {
        throw new Error("No response body reader available");
      }
      const decoder = new TextDecoder();
      let buffer = "";
      let currentEvent = "";
      try {
        while (true) {
          const { done, value } = yield reader.read();
          if (done)
            break;
          const chunk = decoder.decode(value, { stream: true });
          buffer += chunk;
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (line.startsWith("event:")) {
              currentEvent = line.substring(6).trim();
            } else if (line.startsWith("data:")) {
              const data = line.substring(5).trim();
              if (data) {
                try {
                  const parsedData = JSON.parse(data);
                  onEvent == null ? void 0 : onEvent(currentEvent, parsedData);
                } catch (parseError) {
                  if (currentEvent === "connection" && data === "connected") {
                    onEvent == null ? void 0 : onEvent(currentEvent, { status: "connected", message: data });
                  } else {
                    onEvent == null ? void 0 : onEvent(currentEvent, data);
                  }
                }
              }
            } else if (line.trim() === "") {
              currentEvent = "";
            }
          }
        }
      } catch (streamError) {
        ctx.log.debug("SSE Streaming error:", streamError);
        onEvent == null ? void 0 : onEvent("error", streamError);
      } finally {
        reader.releaseLock();
      }
    } catch (error) {
      ctx.log.debug("SSE Connection error:", error);
      onEvent == null ? void 0 : onEvent("error", error);
    }
    return {
      abort: () => abortController.abort()
    };
  });
}
function startSSEListener(ctx) {
  return __async(this, null, function* () {
    let currentConnection = null;
    let errorCount = 0;
    try {
      ctx.log.debug("Attempting SSE connection");
      const accessKey = ctx.env.LT_ACCESS_KEY;
      const username = ctx.env.LT_USERNAME;
      const basicAuthToken = createBasicAuthToken(username, accessKey);
      ctx.log.debug(`Basic auth token: ${basicAuthToken}`);
      currentConnection = yield listenToSmartUISSE(
        ctx.env.SMARTUI_SSE_URL,
        basicAuthToken,
        ctx,
        (eventType, data) => {
          switch (eventType) {
            case "open":
              ctx.log.debug("Connected to SSE server");
              break;
            case "connection":
              ctx.log.debug("Connection confirmed:", data);
              break;
            case "Dot_buildCompleted":
              ctx.log.debug("Build completed");
              ctx.log.info(chalk__default.default.green.bold("Build completed"));
              process.exit(0);
            case "DOTUIError":
              if (data.buildId == ctx.build.id) {
                errorCount++;
                ctx.log.info(chalk__default.default.red.bold(`Error: ${data.message}`));
              }
              break;
            case "DOTUIWarning":
              if (data.buildId == ctx.build.id) {
                ctx.log.info(chalk__default.default.yellow.bold(`Warning: ${data.message}`));
              }
              break;
            case "error":
              ctx.log.debug("SSE Error occurred:", data);
              currentConnection == null ? void 0 : currentConnection.abort();
              return;
          }
        }
      );
    } catch (error) {
      ctx.log.debug("Failed to start SSE listener:", error);
    }
  });
}
function resolveCustomCSS(cssValue, configPath, logger2) {
  if (!cssValue || typeof cssValue !== "string") {
    throw new Error("customCSS must be a non-empty string");
  }
  const trimmed = cssValue.trim();
  if (trimmed.length === 0) {
    throw new Error("customCSS cannot be empty");
  }
  const path7 = __require("path");
  const isLikelyFilePath = trimmed.endsWith(".css") || trimmed.startsWith("./") || trimmed.startsWith("../") || trimmed.startsWith("/") || path7.isAbsolute(trimmed);
  if (isLikelyFilePath) {
    logger2.debug(`customCSS appears to be a file path: ${trimmed}`);
    const ext = path7.extname(trimmed).toLowerCase();
    if (ext && ext !== ".css") {
      throw new Error(`Invalid customCSS file type: ${ext}. Only .css files are supported.`);
    }
    const baseDir = path7.dirname(configPath);
    const resolvedPath = path7.isAbsolute(trimmed) ? trimmed : path7.resolve(baseDir, trimmed);
    logger2.debug(`Resolved customCSS file path: ${resolvedPath}`);
    if (!fs6__default.default.existsSync(resolvedPath)) {
      throw new Error(`customCSS file not found: ${resolvedPath}`);
    }
    const stats = fs6__default.default.statSync(resolvedPath);
    if (!stats.isFile()) {
      throw new Error(`customCSS path is not a file: ${resolvedPath}`);
    }
    try {
      const cssContent = fs6__default.default.readFileSync(resolvedPath, "utf-8");
      logger2.debug(`Read ${cssContent.length} characters from customCSS file`);
      return cssContent;
    } catch (error) {
      if (error.message.includes("Invalid CSS syntax")) {
        throw error;
      }
      throw new Error(`Failed to read customCSS file: ${error.message}`);
    }
  } else {
    logger2.debug("customCSS appears to be inline CSS");
    return trimmed;
  }
}
function parseCSSFile(cssContent) {
  const rules = [];
  try {
    const ast = postcss__default.default.parse(cssContent);
    ast.walkRules((rule) => {
      var _a, _b;
      const declarations = [];
      rule.walkDecls((decl) => {
        declarations.push({
          property: decl.prop,
          value: decl.value,
          important: decl.important
        });
      });
      rules.push({
        selector: rule.selector,
        declarations,
        source: {
          start: (_a = rule.source) == null ? void 0 : _a.start,
          end: (_b = rule.source) == null ? void 0 : _b.end
        }
      });
    });
  } catch (error) {
    throw new Error(`Failed to parse CSS: ${error.message}`);
  }
  return rules;
}
function validateCSSSelectors(page, cssRules, logger2) {
  return __async(this, null, function* () {
    const failedSelectors = [];
    let successCount = 0;
    for (const rule of cssRules) {
      const selector = rule.selector;
      if (selector.includes(":") || selector.includes("@") || selector.includes("::")) {
        successCount++;
        continue;
      }
      try {
        const elementExists = yield page.evaluate(({ selectorValue }) => {
          try {
            const elements = document.querySelectorAll(selectorValue);
            return elements.length > 0;
          } catch (error) {
            return false;
          }
        }, { selectorValue: selector });
        if (elementExists) {
          successCount++;
          logger2.debug(`CSS selector valid: ${selector}`);
        } else {
          failedSelectors.push(selector);
          logger2.debug(`CSS selector found no elements: ${selector}`);
        }
      } catch (error) {
        failedSelectors.push(selector);
        logger2.debug(`CSS selector validation error for "${selector}": ${error.message}`);
      }
    }
    return {
      successCount,
      failedSelectors,
      totalRules: cssRules.length
    };
  });
}
function generateCSSInjectionReport(validationResult, logger2) {
  const lines = [];
  lines.push(chalk__default.default.cyan("[SmartUI] CSS Injection Report:"));
  if (validationResult.successCount > 0) {
    lines.push(chalk__default.default.green(`[SmartUI] \u2705 Success: ${validationResult.successCount} rules applied.`));
  }
  if (validationResult.failedSelectors.length > 0) {
    lines.push(chalk__default.default.yellow(`[SmartUI] \u26A0\uFE0F  Warning: ${validationResult.failedSelectors.length} selector(s) failed to find an element:`));
    validationResult.failedSelectors.forEach((selector) => {
      lines.push(chalk__default.default.yellow(`[SmartUI]   - ${selector}`));
    });
  }
  const report = lines.join("\n");
  logger2.info(report);
  return report;
}

// src/lib/server.ts
var fp = require_find_free_port();
var uploadDomToS3ViaEnv = process.env.USE_LAMBDA_INTERNAL || false;
function findAvailablePort(server, startPort, log2) {
  return __async(this, null, function* () {
    let currentPort = startPort;
    try {
      yield server.listen({ port: currentPort });
      return currentPort;
    } catch (error) {
      if (error.code === "EADDRINUSE") {
        log2.debug(`Port ${currentPort} is in use, finding available port in range 49100-60000`);
        const availablePorts = yield fp(constants_default.MIN_PORT_RANGE, constants_default.MAX_PORT_RANGE);
        if (availablePorts.length > 0) {
          const freePort = availablePorts[0];
          yield server.listen({ port: freePort });
          log2.debug(`Found and started server on port ${freePort}`);
          return freePort;
        } else {
          throw new Error("No available ports found in range 49100-60000");
        }
      } else {
        throw error;
      }
    }
  });
}
var server_default = (ctx) => __async(void 0, null, function* () {
  const server = fastify__default.default({
    logger: {
      level: "debug",
      stream: { write: (message) => {
        ctx.log.debug(message);
      } }
    },
    bodyLimit: 3e7
  });
  const opts = {};
  const SMARTUI_DOM = fs6.readFileSync(path3__default.default.resolve(__dirname, "dom-serializer.js"), "utf-8");
  server.get("/healthcheck", opts, (_, reply) => {
    reply.code(200).send({ cliVersion: ctx.cliVersion });
  });
  server.get("/domserializer", opts, (request, reply) => {
    reply.code(200).send({ data: { dom: SMARTUI_DOM } });
  });
  server.post("/snapshot", opts, (request, reply) => __async(void 0, null, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let replyCode;
    let replyBody;
    try {
      let { snapshot, testType } = request.body;
      if (!validateSnapshot(snapshot))
        throw new Error(validateSnapshot.errors[0].message);
      if (((_a = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _a.approvalThreshold) !== void 0 && ((_b = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _b.rejectionThreshold) !== void 0) {
        if (((_c = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _c.rejectionThreshold) <= ((_d = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _d.approvalThreshold)) {
          throw new Error(`Invalid snapshot options; rejectionThreshold (${snapshot.options.rejectionThreshold}) must be greater than approvalThreshold (${snapshot.options.approvalThreshold})`);
        }
      }
      snapshot.name = (_e = snapshot == null ? void 0 : snapshot.name) == null ? void 0 : _e.trim();
      const sessionId = (_f = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _f.sessionId;
      let capsBuildId = "";
      const contextId = (_g = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _g.contextId;
      if (sessionId) {
        if ((_h = ctx.sessionCapabilitiesMap) == null ? void 0 : _h.has(sessionId)) {
          const cachedCapabilities = ctx.sessionCapabilitiesMap.get(sessionId);
          capsBuildId = (cachedCapabilities == null ? void 0 : cachedCapabilities.buildId) || "";
        } else {
          try {
            let fetchedCapabilitiesResp = yield ctx.client.getSmartUICapabilities(sessionId, ctx.config, ctx.git, ctx.log, ctx.isStartExec, ctx.options.baselineBuild);
            capsBuildId = (fetchedCapabilitiesResp == null ? void 0 : fetchedCapabilitiesResp.buildId) || "";
            ctx.log.debug(`fetch caps for sessionId: ${sessionId} are ${JSON.stringify(fetchedCapabilitiesResp)}`);
            if (capsBuildId) {
              ctx.sessionCapabilitiesMap.set(sessionId, fetchedCapabilitiesResp);
            } else if (fetchedCapabilitiesResp && (fetchedCapabilitiesResp == null ? void 0 : fetchedCapabilitiesResp.sessionId)) {
              ctx.sessionCapabilitiesMap.set(sessionId, fetchedCapabilitiesResp);
            }
          } catch (error) {
            ctx.log.debug(`Failed to fetch capabilities for sessionId ${sessionId}: ${error.message}`);
          }
        }
        if (capsBuildId && capsBuildId !== "") {
          process.env.SMARTUI_BUILD_ID = capsBuildId;
        }
      }
      ctx.testType = testType;
      if (contextId && !ctx.contextToSnapshotMap) {
        ctx.contextToSnapshotMap = /* @__PURE__ */ new Map();
        ctx.log.debug(`Initialized empty context mapping map for contextId: ${contextId}`);
      }
      if (contextId && ctx.contextToSnapshotMap) {
        ctx.contextToSnapshotMap.set(contextId, "0");
        ctx.log.debug(`Marking contextId as captured and added to queue: ${contextId}`);
      }
      if (contextId) {
        (_i = ctx.snapshotQueue) == null ? void 0 : _i.enqueueFront(snapshot);
      } else {
        (_j = ctx.snapshotQueue) == null ? void 0 : _j.enqueue(snapshot);
      }
      ctx.isSnapshotCaptured = true;
      replyCode = 200;
      replyBody = { data: { message: "success", warnings: [] } };
    } catch (error) {
      ctx.log.debug(`snapshot failed; ${error}`);
      replyCode = 500;
      replyBody = { error: { message: error.message } };
    }
    return reply.code(replyCode).send(replyBody);
  }));
  server.post("/stop", opts, (_, reply) => __async(void 0, null, function* () {
    var _a, _b, _c, _d;
    let replyCode;
    let replyBody;
    try {
      ctx.log.info("Received stop command. Finalizing build ...");
      if (ctx.config.delayedUpload) {
        ctx.log.debug("started after processing because of delayedUpload");
        (_a = ctx.snapshotQueue) == null ? void 0 : _a.startProcessingfunc();
      }
      yield new Promise((resolve) => {
        const intervalId = setInterval(() => {
          var _a2, _b2;
          if (((_a2 = ctx.snapshotQueue) == null ? void 0 : _a2.isEmpty()) && !((_b2 = ctx.snapshotQueue) == null ? void 0 : _b2.isProcessing())) {
            clearInterval(intervalId);
            resolve();
          }
        }, 1e3);
      });
      let buildUrls = `build url: ${ctx.build.url}
`;
      for (const [sessionId, capabilities] of ctx.sessionCapabilitiesMap.entries()) {
        try {
          const buildId = (capabilities == null ? void 0 : capabilities.buildId) || "";
          const projectToken = (capabilities == null ? void 0 : capabilities.projectToken) || "";
          const totalSnapshots = (capabilities == null ? void 0 : capabilities.snapshotCount) || 0;
          const sessionBuildUrl = (capabilities == null ? void 0 : capabilities.buildURL) || "";
          const testId = (capabilities == null ? void 0 : capabilities.id) || "";
          ctx.log.debug(`Capabilities for sessionId ${sessionId}: ${JSON.stringify(capabilities)}`);
          if (buildId && projectToken) {
            yield ctx.client.finalizeBuildForCapsWithToken(buildId, totalSnapshots, projectToken, ctx.log);
            if (ctx.autoTunnelStarted) {
              yield startPollingForTunnel(ctx, buildId, false, projectToken, capabilities == null ? void 0 : capabilities.buildName);
            }
          }
          if (testId && buildId) {
            buildUrls += `TestId ${testId}: ${sessionBuildUrl}
`;
          }
        } catch (error) {
          ctx.log.debug(`Error finalizing build for session ${sessionId}: ${error.message}`);
        }
      }
      if (ctx.build && ctx.build.id) {
        yield ctx.client.finalizeBuild(ctx.build.id, ctx.totalSnapshots, ctx.log);
        let uploadCLILogsToS3 = ((_b = ctx == null ? void 0 : ctx.config) == null ? void 0 : _b.useLambdaInternal) || uploadDomToS3ViaEnv;
        if (!uploadCLILogsToS3) {
          ctx.log.debug(`Log file to be uploaded`);
          let resp = yield ctx.client.getS3PreSignedURL(ctx);
          yield ctx.client.uploadLogs(ctx, resp.data.url);
        } else {
          ctx.log.debug(`Skipping upload of CLI logs as useLambdaInternal is set`);
        }
      }
      if (ctx.tunnelDetails && ctx.tunnelDetails.tunnelHost != "" && ((_c = ctx.build) == null ? void 0 : _c.id)) {
        yield startPollingForTunnel(ctx, ctx.build.id, false, "", "");
      }
      if (ctx.autoTunnelStarted && isTunnelPolling === null) {
        yield stopTunnelHelper(ctx);
      }
      yield (_d = ctx.browser) == null ? void 0 : _d.close();
      if (ctx.server) {
        ctx.server.close();
      }
      if (pingIntervalId !== null) {
        clearInterval(pingIntervalId);
        ctx.log.debug("Ping polling stopped immediately.");
      }
      replyCode = 200;
      replyBody = { data: { message: "success", type: "DELETE" } };
    } catch (error) {
      ctx.log.debug(error);
      ctx.log.debug(`stop endpoint failed; ${error}`);
      replyCode = 500;
      replyBody = { error: { message: error.message } };
    }
    ctx.log.info("Stop command processed. Tearing down server.");
    return reply.code(replyCode).send(replyBody);
  }));
  server.get("/ping", opts, (_, reply) => {
    reply.code(200).send({ status: "Server is running", version: ctx.cliVersion });
  });
  server.get("/snapshot/status", opts, (request, reply) => __async(void 0, null, function* () {
    var _a;
    let replyCode;
    let replyBody;
    try {
      ctx.log.debug(`request.query : ${JSON.stringify(request.query)}`);
      const { contextId, pollTimeout, snapshotName: rawSnapshotName } = request.query;
      const snapshotName = rawSnapshotName == null ? void 0 : rawSnapshotName.trim();
      if (!contextId || !snapshotName) {
        throw new Error("contextId and snapshotName are required parameters");
      }
      const timeoutDuration = pollTimeout * 1e3 || 3e4;
      if ((_a = ctx.contextToSnapshotMap) == null ? void 0 : _a.has(contextId)) {
        let contextStatus = ctx.contextToSnapshotMap.get(contextId);
        let counter = 60;
        while (contextStatus === "0") {
          if (counter <= 0) {
            throw new Error("Snapshot processing failed");
          }
          contextStatus = ctx.contextToSnapshotMap.get(contextId);
          yield new Promise((resolve) => setTimeout(resolve, 5e3));
          counter--;
        }
        if (contextStatus === "2") {
          throw new Error("Snapshot Failed");
        }
        ctx.log.debug("Snapshot uploaded successfully");
        const buildId = contextStatus;
        if (!buildId) {
          throw new Error(`No buildId found for contextId: ${contextId}`);
        }
        let lastExternalResponse = null;
        const startTime = Date.now();
        while (true) {
          try {
            const externalResponse = yield ctx.client.getSnapshotStatus(
              buildId,
              snapshotName,
              contextId,
              ctx
            );
            lastExternalResponse = externalResponse;
            if (externalResponse.statusCode === 200) {
              replyCode = 200;
              replyBody = externalResponse.data;
              replyBody.error = externalResponse.error.message;
              return reply.code(replyCode).send(replyBody);
            } else if (externalResponse.statusCode === 202) {
              replyBody = externalResponse.data;
              ctx.log.debug(`External API attempt: Still processing, Pending Screenshots ${externalResponse.snapshotCount}`);
              yield new Promise((resolve) => setTimeout(resolve, 5e3));
            } else if (externalResponse.statusCode === 404) {
              ctx.log.debug(`Snapshot still processing, not uploaded`);
              yield new Promise((resolve) => setTimeout(resolve, 5e3));
            } else {
              ctx.log.debug(`Unexpected response from external API: ${JSON.stringify(externalResponse)}`);
              replyCode = 500;
              return reply.code(replyCode).send(externalResponse);
            }
            ctx.log.debug(`timeoutDuration: ${timeoutDuration}`);
            ctx.log.debug(`Time passed: ${Date.now() - startTime}`);
            if (Date.now() - startTime > timeoutDuration) {
              replyCode = 202;
              replyBody = lastExternalResponse.data;
              replyBody.error = "Request timed out, Snapshot still processing";
              return reply.code(replyCode).send(replyBody);
            }
          } catch (externalApiError) {
            ctx.log.debug(`External API call failed: ${externalApiError.message}`);
            replyCode = 500;
            replyBody = {
              error: {
                message: `External API call failed: ${externalApiError.message}`
              }
            };
            return reply.code(replyCode).send(replyBody);
          }
        }
      } else {
        replyCode = 404;
        replyBody = { error: { message: `No snapshot found for contextId: ${contextId}` } };
        return reply.code(replyCode).send(replyBody);
      }
    } catch (error) {
      ctx.log.debug(`snapshot status failed; ${error}`);
      replyCode = 500;
      replyBody = { error: { message: error.message } };
      return reply.code(replyCode).send(replyBody);
    }
  }));
  server.get("/build/info", opts, (request, reply) => __async(void 0, null, function* () {
    let replyCode;
    let replyBody;
    try {
      if (ctx.build && ctx.build.id) {
        const buildInfo = ctx.build;
        const data = {
          buildId: buildInfo.id,
          buildName: buildInfo.name,
          baseline: buildInfo.baseline,
          projectToken: ctx.env.PROJECT_TOKEN || ""
        };
        replyCode = 200;
        replyBody = { data };
      } else {
        throw new Error("Build information is not available");
      }
    } catch (error) {
      ctx.log.debug(`build info failed; ${error}`);
      replyCode = 500;
      replyBody = { error: { message: error.message } };
    }
    return reply.code(replyCode).send(replyBody);
  }));
  if (ctx.sourceCommand && ctx.sourceCommand === "exec-start") {
    yield server.listen({ port: ctx.options.port });
    let { port } = server.addresses()[0];
    process.env.SMARTUI_SERVER_ADDRESS = `http://localhost:${port}`;
    process.env.CYPRESS_SMARTUI_SERVER_ADDRESS = `http://localhost:${port}`;
    ctx.log.debug(`Server started successfully on port ${port}`);
  } else {
    const actualPort = yield findAvailablePort(server, ctx.options.port, ctx.log);
    process.env.SMARTUI_SERVER_ADDRESS = `http://localhost:${actualPort}`;
    process.env.CYPRESS_SMARTUI_SERVER_ADDRESS = `http://localhost:${actualPort}`;
    ctx.log.debug(`Server started successfully on port ${actualPort}`);
  }
  return server;
});

// src/lib/env.ts
var env_default = () => {
  const {
    PROJECT_TOKEN = "",
    SMARTUI_CLIENT_API_URL = "https://api.lambdatest.com/visualui/1.0",
    SMARTUI_UPLOAD_URL = "https://api.lambdatest.com",
    SMARTUI_GIT_INFO_FILEPATH,
    SMARTUI_DO_NOT_USE_CAPTURED_COOKIES,
    HTTP_PROXY,
    HTTPS_PROXY,
    SMARTUI_HTTP_PROXY,
    SMARTUI_HTTPS_PROXY,
    GIT_URL,
    BASIC_AUTH_USERNAME,
    BASIC_AUTH_PASSWORD,
    FIGMA_TOKEN,
    LT_USERNAME,
    LT_ACCESS_KEY,
    LT_SDK_DEBUG,
    BASELINE_BRANCH,
    CURRENT_BRANCH,
    PROJECT_NAME,
    SMARTUI_API_PROXY,
    SMARTUI_API_SKIP_CERTIFICATES,
    USE_REMOTE_DISCOVERY,
    SMART_GIT,
    SHOW_RENDER_ERRORS,
    SMARTUI_SSE_URL = "https://server-events.lambdatest.com",
    LT_SDK_SKIP_EXECUTION_LOGS,
    MAX_CONCURRENT_PROCESSING,
    DO_NOT_USE_USER_AGENT
  } = process.env;
  return {
    PROJECT_TOKEN,
    SMARTUI_CLIENT_API_URL,
    SMARTUI_UPLOAD_URL,
    SMARTUI_GIT_INFO_FILEPATH,
    HTTP_PROXY,
    HTTPS_PROXY,
    SMARTUI_HTTP_PROXY,
    SMARTUI_HTTPS_PROXY,
    GIT_URL,
    BASIC_AUTH_USERNAME,
    BASIC_AUTH_PASSWORD,
    FIGMA_TOKEN,
    LT_USERNAME,
    LT_ACCESS_KEY,
    BASELINE_BRANCH,
    CURRENT_BRANCH,
    LT_SDK_DEBUG: LT_SDK_DEBUG === "true",
    SMARTUI_DO_NOT_USE_CAPTURED_COOKIES: SMARTUI_DO_NOT_USE_CAPTURED_COOKIES === "true",
    PROJECT_NAME,
    SMARTUI_API_PROXY,
    SMARTUI_API_SKIP_CERTIFICATES: SMARTUI_API_SKIP_CERTIFICATES === "true",
    USE_REMOTE_DISCOVERY: USE_REMOTE_DISCOVERY === "true",
    SMART_GIT: SMART_GIT === "true",
    SHOW_RENDER_ERRORS: SHOW_RENDER_ERRORS === "true",
    SMARTUI_SSE_URL,
    LT_SDK_SKIP_EXECUTION_LOGS: LT_SDK_SKIP_EXECUTION_LOGS === "true",
    MAX_CONCURRENT_PROCESSING: MAX_CONCURRENT_PROCESSING ? parseInt(MAX_CONCURRENT_PROCESSING, 10) : 0,
    DO_NOT_USE_USER_AGENT: DO_NOT_USE_USER_AGENT === "true",
    CAPTURE_RENDERING_ERRORS: process.env.CAPTURE_RENDERING_ERRORS === "true"
  };
};
var logContext = {};
function updateLogContext(newContext) {
  logContext = __spreadValues(__spreadValues({}, logContext), newContext);
}
var logLevel = () => {
  let env = env_default();
  return env.LT_SDK_DEBUG ? "debug" : "info";
};
var logger = winston.createLogger({
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf((info) => {
      let contextString = Object.values(logContext).join(" | ");
      let message = typeof info.message === "object" ? stringify__default.default(info.message) : info.message.trim();
      switch (info.level) {
        case "warn":
          message = chalk__default.default.yellow(message);
          break;
        case "error":
          message = chalk__default.default.red(message);
          break;
      }
      return info.level === "info" ? message : `[${contextString}:${info.level}] ` + message;
    })
  ),
  transports: [
    new winston.transports.Console({
      level: logLevel()
    }),
    new winston.transports.File({
      level: "debug",
      filename: constants_default.LOG_FILE_PATH
    })
  ]
});
var logger_default = logger;

// src/tasks/startServer.ts
var startServer_default = (ctx) => {
  return {
    title: `Setting up SmartUI server`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a;
      updateLogContext({ task: "startServer" });
      try {
        ctx2.server = yield server_default(ctx2);
        task.output = chalk__default.default.gray(`listening on port ${(_a = ctx2.server.addresses()[0]) == null ? void 0 : _a.port}`);
        task.title = "SmartUI started";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("SmartUI server setup failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var authExec_default = (ctx) => {
  return {
    title: `Authenticating with SmartUI`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "auth" });
      try {
        if (!ctx2.env.PROJECT_NAME && !ctx2.env.PROJECT_TOKEN) {
          ctx2.authenticatedInitially = false;
          task.output = chalk__default.default.gray(`Empty PROJECT_TOKEN and PROJECT_NAME. Skipping authentication. Expecting SmartUI Capabilities in driver!`);
          task.title = "Skipped Authentication with SmartUI";
        } else {
          const { authResult, orgId, userId } = yield ctx2.client.authExec(ctx2, ctx2.log, ctx2.env);
          if (authResult === 2) {
            task.output = chalk__default.default.gray(`New project '${ctx2.env.PROJECT_NAME}' created successfully`);
          } else if (authResult === 0) {
            task.output = chalk__default.default.gray(`Using existing project token '******#${ctx2.env.PROJECT_TOKEN.split("#").pop()}'`);
          } else if (authResult === 1) {
            task.output = chalk__default.default.gray(`Using existing project '${ctx2.env.PROJECT_NAME}'`);
          }
          ctx2.orgId = orgId;
          ctx2.userId = userId;
          ctx2.authenticatedInitially = true;
          task.title = "Authenticated with SmartUI";
        }
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Authentication failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// package.json
var version = "4.1.48";
var package_default = {
  name: "@lambdatest/smartui-cli",
  version,
  description: "A command line interface (CLI) to run SmartUI tests on LambdaTest",
  files: [
    "dist/**/*"
  ],
  scripts: {
    build: "tsup",
    release: "pnpm run build && pnpm publish --access public --no-git-checks",
    "release:beta": "pnpm run build && pnpm publish --tag beta --access public --no-git-checks",
    "local-build": "pnpm run build && pnpm pack"
  },
  bin: {
    smartui: "./dist/index.cjs"
  },
  type: "module",
  keywords: [
    "lambdatest",
    "smartui",
    "cli"
  ],
  author: "LambdaTest <keys@lambdatest.com>",
  license: "MIT",
  dependencies: {
    "@lambdatest/node-tunnel": "^4.0.9",
    "@playwright/browser-chromium": "^1.47.2",
    "@playwright/browser-firefox": "^1.47.2",
    "@playwright/browser-webkit": "^1.47.2",
    "@playwright/test": "^1.47.2",
    "@types/cross-spawn": "^6.0.4",
    "@types/json-stringify-safe": "^5.0.3",
    "@types/node": "^20.8.9",
    "@types/which": "^3.0.2",
    ajv: "^8.12.0",
    "ajv-errors": "^3.0.0",
    axios: "^1.6.0",
    chalk: "^4.1.2",
    commander: "^11.1.0",
    "cross-spawn": "^7.0.3",
    fastify: "^4.24.3",
    "form-data": "^4.0.0",
    "json-stringify-safe": "^5.0.1",
    listr2: "^7.0.1",
    "node-cache": "^5.1.2",
    postcss: "^8.5.6",
    sharp: "^0.33.4",
    tsup: "^7.2.0",
    uuid: "^11.0.3",
    which: "^4.0.0",
    winston: "^3.10.0"
  },
  overrides: {
    "simple-swizzle": "0.2.2"
  },
  devDependencies: {
    "find-free-port": "^2.0.0",
    typescript: "^5.3.2"
  }
};
var httpClient = class {
  handleHttpError(error, log2) {
    var _a;
    if (error && error.response) {
      log2.debug(`http response error: ${JSON.stringify({
        status: error.response.status,
        body: error.response.data
      })}`);
      throw new Error(((_a = error.response.data) == null ? void 0 : _a.message) || error.response.data || `HTTP ${error.response.status} error`);
    }
    log2.debug(`http request failed: ${error.message}`);
    throw new Error(error.message);
  }
  constructor({ SMARTUI_CLIENT_API_URL, PROJECT_TOKEN, PROJECT_NAME, LT_USERNAME, LT_ACCESS_KEY, SMARTUI_API_PROXY, SMARTUI_API_SKIP_CERTIFICATES }) {
    this.projectToken = PROJECT_TOKEN || "";
    this.projectName = PROJECT_NAME || "";
    this.username = LT_USERNAME || "";
    this.accessKey = LT_ACCESS_KEY || "";
    let proxyUrl = null;
    try {
      const urlStr = (SMARTUI_API_PROXY == null ? void 0 : SMARTUI_API_PROXY.startsWith("http")) ? SMARTUI_API_PROXY : `http://${SMARTUI_API_PROXY}`;
      proxyUrl = SMARTUI_API_PROXY ? new URL(urlStr) : null;
    } catch (error) {
      console.error("Invalid proxy URL:", error);
    }
    const axiosConfig = {
      baseURL: SMARTUI_CLIENT_API_URL,
      proxy: proxyUrl ? __spreadValues({
        host: proxyUrl.hostname,
        port: proxyUrl.port ? Number(proxyUrl.port) : 80
      }, proxyUrl.username && proxyUrl.password ? {
        auth: {
          username: proxyUrl.username,
          password: proxyUrl.password
        }
      } : {}) : false
    };
    if (SMARTUI_API_SKIP_CERTIFICATES) {
      axiosConfig.httpsAgent = new https__namespace.default.Agent({
        rejectUnauthorized: false
      });
    }
    this.axiosInstance = axios__default.default.create(axiosConfig);
    this.axiosInstance.interceptors.request.use((config) => {
      if (!config.headers["projectToken"] && this.projectToken !== "") {
        config.headers["projectToken"] = this.projectToken;
      } else if (!config.headers["projectName"] && this.projectName !== "") {
        config.headers["projectName"] = this.projectName;
        if (!config.headers["username"] || config.headers["username"] === "") {
          config.headers["username"] = this.username;
        }
        if (!config.headers["accessKey"] || config.headers["accessKey"] === "") {
          config.headers["accessKey"] = this.accessKey;
        }
      }
      return config;
    });
    this.axiosInstance.interceptors.response.use(
      (response) => response,
      (error) => __async(this, null, function* () {
        var _a;
        const { config } = error;
        if (config && config.url === "/screenshot" && config.method === "post" && ((_a = error == null ? void 0 : error.response) == null ? void 0 : _a.status) !== 401) {
          if (!config.retryCount) {
            config.retryCount = 0;
            config.retry = 2;
            config.retryDelay = 5e3;
          }
          if (config.retryCount < config.retry) {
            config.retryCount += 1;
            yield new Promise((resolve) => setTimeout(resolve, config.retryDelay));
            config.timeout = 3e4;
            return this.axiosInstance(config);
          }
          return Promise.reject(error);
        } else {
          return Promise.reject(error);
        }
      })
    );
  }
  request(config, log2) {
    return __async(this, null, function* () {
      log2.debug(`http request: ${config.method} ${config.url}`);
      if (config && config.data && !config.data.skipLogging && !config.data.name && !config.data.snapshot && config.method !== "PUT") {
        log2.debug(config.data);
      }
      if (config && config.data && !config.data.skipLogging && config.data.snapshotUuid && config.method !== "PUT") {
        log2.debug(config.data);
      }
      return this.axiosInstance.request(config).then((resp) => {
        if (resp) {
          log2.debug(`http response: ${JSON.stringify({
            status: resp.status,
            headers: resp.headers,
            body: resp.data
          })}`);
          if (resp.data !== "") {
            return resp.data;
          } else {
            return resp;
          }
        } else {
          log2.debug(`empty response: ${JSON.stringify(resp)}`);
          return {};
        }
      }).catch((error) => {
        var _a;
        if (error.response) {
          log2.debug(`http response: ${JSON.stringify({
            status: error.response.status,
            headers: error.response.headers,
            body: error.response.data
          })}`);
          throw new Error(((_a = error.response.data.error) == null ? void 0 : _a.message) || error.response.data.message || error.response.data);
        }
        if (error.request) {
          log2.debug(`http request failed: ${error.toJSON()}`);
          throw new Error(error.toJSON().message);
        }
        log2.debug(`http request failed: ${error.message}`);
        throw new Error(error.message);
      });
    });
  }
  auth(log2, env) {
    return __async(this, null, function* () {
      let result = 1;
      if (this.projectToken) {
        result = 0;
      }
      const response = yield this.request({
        url: "/token/verify",
        method: "GET",
        headers: {
          userName: env.LT_USERNAME,
          accessKey: env.LT_ACCESS_KEY
        }
      }, log2);
      if (response && response.projectToken) {
        let orgId = 0;
        let userId = 0;
        this.projectToken = response.projectToken;
        env.PROJECT_TOKEN = response.projectToken;
        if (response.message && response.message.includes("Project created successfully")) {
          result = 2;
        }
        if (response.orgId) {
          orgId = response.orgId;
        }
        if (response.userId) {
          userId = response.userId;
        }
        return { authResult: result, orgId, userId };
      } else {
        throw new Error("Authentication failed, project token not received");
      }
    });
  }
  authExec(ctx, log2, env) {
    return __async(this, null, function* () {
      var _a, _b;
      let authResult = 1;
      let userName = ctx.env.LT_USERNAME;
      let passWord = ctx.env.LT_ACCESS_KEY;
      if (ctx.config.tunnel) {
        if (((_a = ctx.config.tunnel) == null ? void 0 : _a.user) && ((_b = ctx.config.tunnel) == null ? void 0 : _b.key)) {
          userName = ctx.config.tunnel.user;
          passWord = ctx.config.tunnel.key;
        } else {
          userName = this.username;
          passWord = this.accessKey;
        }
      }
      if (this.projectToken) {
        authResult = 0;
      }
      const response = yield this.request({
        url: "/token/verify",
        method: "GET",
        headers: {
          username: userName,
          accessKey: passWord
        }
      }, log2);
      if (response && response.projectToken) {
        let orgId = 0;
        let userId = 0;
        this.projectToken = response.projectToken;
        env.PROJECT_TOKEN = response.projectToken;
        if (response.message && response.message.includes("Project created successfully")) {
          authResult = 2;
        }
        if (response.orgId) {
          orgId = response.orgId;
        }
        if (response.userId) {
          userId = response.userId;
        }
        return { authResult, orgId, userId };
      } else {
        if (response && response.message) {
          throw new Error(response.message);
        }
        throw new Error("Authentication failed, project token not received. Refer to the smartui.log file for more information");
      }
    });
  }
  createBuild(git, config, log2, buildName, isStartExec, smartGit, markBaseline, baselineBuild, scheduled, userName, accessKey) {
    return this.request({
      url: "/build",
      method: "POST",
      headers: {
        userName,
        accessKey
      },
      data: {
        git,
        config,
        buildName,
        isStartExec,
        packageVersion: package_default.version,
        smartGit,
        markBaseline,
        baselineBuild,
        scheduled
      }
    }, log2);
  }
  getScreenshotData(buildId, baseline, log2, projectToken, buildName) {
    log2.debug(`Fetching screenshot data for buildId: ${buildId}  having  buildName: ${buildName} with baseline: ${baseline}`);
    return this.request({
      url: "/screenshot",
      method: "GET",
      params: { buildId, baseline, buildName },
      headers: { projectToken }
    }, log2);
  }
  getTunnelDetails(ctx, log2) {
    var _a, _b, _c;
    const data = {
      orgId: ctx.orgId,
      userId: ctx.userId,
      userName: (_a = ctx.config.tunnel) == null ? void 0 : _a.user,
      password: (_b = ctx.config.tunnel) == null ? void 0 : _b.key
    };
    if ((_c = ctx.config.tunnel) == null ? void 0 : _c.tunnelName) {
      data.tunnelName = ctx.config.tunnel.tunnelName;
    }
    return this.request({
      url: "/tunnel",
      method: "POST",
      data
    }, log2);
  }
  ping(buildId, log2) {
    return this.request({
      url: "/build/ping",
      method: "POST",
      data: {
        buildId
      }
    }, log2);
  }
  getSmartUICapabilities(sessionId, config, git, log2, isStartExec, baselineBuild) {
    return this.request({
      url: "/sessions/capabilities",
      method: "GET",
      params: {
        sessionId
      },
      data: {
        git,
        config,
        isStartExec,
        baselineBuild,
        packageVersion: package_default.version
      },
      headers: {
        projectToken: "",
        projectName: "",
        username: "",
        accessKey: ""
      }
    }, log2);
  }
  finalizeBuild(buildId, totalSnapshots, log2) {
    let params = { buildId };
    if (totalSnapshots > -1)
      params.totalSnapshots = totalSnapshots;
    return this.request({
      url: "/build",
      method: "DELETE",
      params
    }, log2);
  }
  finalizeBuildForCapsWithToken(buildId, totalSnapshots, projectToken, log2) {
    let params = { buildId };
    if (totalSnapshots > -1)
      params.totalSnapshots = totalSnapshots;
    return this.request({
      url: "/build",
      method: "DELETE",
      params,
      headers: {
        projectToken
        // Use projectToken dynamically
      }
    }, log2);
  }
  uploadSnapshot(ctx, snapshot, discoveryErrors) {
    return this.request({
      url: `/builds/${ctx.build.id}/snapshot`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        snapshot,
        test: {
          type: ctx.testType,
          source: "cli"
        },
        discoveryErrors
      }
    }, ctx.log);
  }
  processSnapshot(ctx, snapshot, snapshotUuid, discoveryErrors, variantCount, sync = false, approvalThreshold, rejectionThreshold) {
    const requestData = {
      name: snapshot.name,
      url: snapshot.url,
      snapshotUuid,
      variantCount,
      test: {
        type: ctx.testType,
        source: "cli"
      },
      discoveryErrors,
      doRemoteDiscovery: snapshot.options.doRemoteDiscovery,
      sync
    };
    if (approvalThreshold !== void 0) {
      requestData.approvalThreshold = approvalThreshold;
    }
    if (rejectionThreshold !== void 0) {
      requestData.rejectionThreshold = rejectionThreshold;
    }
    return this.request({
      url: `/build/${ctx.build.id}/snapshot`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: requestData
    }, ctx.log);
  }
  processSnapshotCaps(ctx, snapshot, snapshotUuid, capsBuildId, capsProjectToken, discoveryErrors, variantCount, sync = false, approvalThreshold, rejectionThreshold) {
    const requestData = {
      name: snapshot.name,
      url: snapshot.url,
      snapshotUuid,
      variantCount,
      test: {
        type: ctx.testType,
        source: "cli"
      },
      doRemoteDiscovery: snapshot.options.doRemoteDiscovery,
      discoveryErrors,
      sync
    };
    if (approvalThreshold !== void 0) {
      requestData.approvalThreshold = approvalThreshold;
    }
    if (rejectionThreshold !== void 0) {
      requestData.rejectionThreshold = rejectionThreshold;
    }
    return this.request({
      url: `/build/${capsBuildId}/snapshot`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
      },
      data: requestData
    }, ctx.log);
  }
  uploadSnapshotForCaps(ctx, snapshot, capsBuildId, capsProjectToken, discoveryErrors, variantCount, sync = false, approvalThreshold, rejectionThreshold) {
    const buildId = capsBuildId !== "" ? capsBuildId : ctx.build.id;
    const requestData = {
      snapshot,
      test: {
        type: ctx.testType,
        source: "cli"
      },
      discoveryErrors,
      variantCount,
      sync
    };
    if (approvalThreshold !== void 0) {
      requestData.approvalThreshold = approvalThreshold;
    }
    if (rejectionThreshold !== void 0) {
      requestData.rejectionThreshold = rejectionThreshold;
    }
    return this.request({
      url: `/builds/${buildId}/snapshot`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
        // Use capsProjectToken dynamically
      },
      data: requestData
    }, ctx.log);
  }
  uploadScreenshot({ id: buildId, name: buildName, baseline }, ssPath, ssName, browserName, viewport, url = "", log2, discoveryErrors, ctx) {
    browserName = browserName === constants_default.SAFARI ? constants_default.WEBKIT : browserName;
    const file = fs6__default.default.readFileSync(ssPath);
    const form = new FormData__default.default();
    form.append("screenshot", file, { filename: `${ssName}.png`, contentType: "image/png" });
    form.append("browser", browserName);
    form.append("viewport", viewport);
    form.append("buildId", buildId);
    form.append("buildName", buildName);
    form.append("screenshotName", ssName);
    form.append("baseline", baseline.toString());
    form.append("pageUrl", url);
    if ((ctx == null ? void 0 : ctx.env.CAPTURE_RENDERING_ERRORS) && discoveryErrors) {
      form.append("discoveryErrors", JSON.stringify(discoveryErrors));
    }
    return this.axiosInstance.request({
      url: `/screenshot`,
      method: "POST",
      headers: form.getHeaders(),
      data: form,
      timeout: 3e4
    }).then(() => {
      log2.debug(`${ssName} for ${browserName} ${viewport} uploaded successfully`);
    }).catch((error) => {
      log2.error(`Unable to upload screenshot ${JSON.stringify(error)}`);
      if (error && error.response && error.response.data && error.response.data.error) {
        throw new Error(error.response.data.error.message);
      }
      if (error) {
        throw new Error(JSON.stringify(error));
      }
    });
  }
  checkUpdate(log2) {
    return this.request({
      url: `/packageinfo`,
      method: "GET",
      headers: { "Content-Type": "application/json" },
      params: {
        packageName: package_default.name,
        packageVersion: package_default.version
      }
    }, log2);
  }
  getFigmaFilesAndImages(figmaFileToken, figmaToken, queryParams, authToken, depth, markBaseline, buildName, log2) {
    const requestBody = {
      figma_file_token: figmaFileToken,
      figma_token: figmaToken,
      query_params: queryParams,
      auth: authToken,
      depth,
      mark_base_line: markBaseline,
      build_name: buildName
    };
    return this.request({
      url: "/uploadfigma",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      data: JSON.stringify(requestBody)
    }, log2);
  }
  getS3PreSignedURL(ctx) {
    return this.request({
      url: `/loguploadurl`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        buildId: ctx.build.id
      }
    }, ctx.log);
  }
  getS3PreSignedURLForCaps(ctx, capsBuildId, capsProjectToken) {
    return this.request({
      url: `/loguploadurl`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
      },
      data: {
        buildId: capsBuildId
      }
    }, ctx.log);
  }
  getS3PresignedURLForSnapshotUpload(ctx, snapshotName, snapshotUuid) {
    return this.request({
      url: `/snapshotuploadurl`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: {
        buildId: ctx.build.id,
        snapshotName,
        snapshotUuid
      }
    }, ctx.log);
  }
  getS3PresignedURLForSnapshotUploadCaps(ctx, snapshotName, snapshotUuid, capsBuildId, capsProjectToken) {
    return this.request({
      url: `/snapshotuploadurl`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
      },
      data: {
        buildId: capsBuildId,
        snapshotName,
        snapshotUuid
      }
    }, ctx.log);
  }
  sendDomToLSRS(ctx, snapshot, snapshotUuid) {
    return this.request({
      url: `/upload/dom`,
      method: "POST",
      data: {
        buildId: ctx.build.id,
        snapshotName: snapshot.name,
        snapshotUuid,
        domContent: snapshot,
        skipLogging: true
      }
    }, ctx.log);
  }
  sendDomToLSRSForCaps(ctx, snapshot, snapshotUuid, capsBuildId, capsProjectToken) {
    return this.request({
      url: `/upload/dom`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
      },
      data: {
        buildId: capsBuildId,
        snapshotName: snapshot.name,
        snapshotUuid,
        domContent: snapshot,
        skipLogging: true
      }
    }, ctx.log);
  }
  uploadLogs(ctx, uploadURL) {
    const fileStream = fs6__default.default.createReadStream(constants_default.LOG_FILE_PATH);
    const { size } = fs6__default.default.statSync(constants_default.LOG_FILE_PATH);
    return this.request({
      url: uploadURL,
      method: "PUT",
      headers: {
        "Content-Type": "text/plain",
        "Content-Length": size
      },
      data: fileStream,
      maxBodyLength: Infinity,
      // prevent axios from limiting the body size
      maxContentLength: Infinity
      // prevent axios from limiting the content size
    }, ctx.log);
  }
  uploadLogsForCaps(ctx, uploadURL) {
    const logContent = fs6__default.default.readFileSync(constants_default.LOG_FILE_PATH);
    const { size } = fs6__default.default.statSync(constants_default.LOG_FILE_PATH);
    return this.request({
      url: uploadURL,
      method: "PUT",
      headers: {
        "Content-Type": "text/plain",
        "Content-Length": size
      },
      data: logContent,
      maxBodyLength: Infinity,
      // prevent axios from limiting the body size
      maxContentLength: Infinity
      // prevent axios from limiting the content size
    }, ctx.log);
  }
  sendCliLogsToLSRS(ctx) {
    const logContent = fs6__default.default.readFileSync(constants_default.LOG_FILE_PATH, "utf-8");
    return this.request({
      url: `/upload/logs`,
      method: "POST",
      data: {
        buildId: ctx.build.id,
        logContent,
        skipLogging: true
      }
    }, ctx.log);
  }
  sendCliLogsToLSRSForCaps(ctx, capsBuildId, capsProjectToken) {
    const logContent = fs6__default.default.readFileSync(constants_default.LOG_FILE_PATH, "utf-8");
    return this.request({
      url: `/upload/logs`,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
      },
      data: {
        buildId: capsBuildId,
        logContent,
        skipLogging: true
      }
    }, ctx.log);
  }
  uploadSnapshotToS3(ctx, uploadURL, snapshot) {
    return this.request({
      url: uploadURL,
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      data: snapshot,
      maxBodyLength: Infinity,
      // prevent axios from limiting the body size
      maxContentLength: Infinity
      // prevent axios from limiting the content size
    }, ctx.log);
  }
  uploadSnapshotToS3Caps(ctx, uploadURL, snapshot, capsProjectToken) {
    return this.request({
      url: uploadURL,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        projectToken: capsProjectToken !== "" ? capsProjectToken : this.projectToken
      },
      data: snapshot,
      maxBodyLength: Infinity,
      // prevent axios from limiting the body size
      maxContentLength: Infinity
      // prevent axios from limiting the content size
    }, ctx.log);
  }
  processWebFigma(requestBody, log2) {
    requestBody.packageVersion = package_default.version;
    return this.request({
      url: "figma-web/upload",
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      data: JSON.stringify(requestBody)
    }, log2);
  }
  fetchWebFigma(buildId, log2) {
    return this.request({
      url: "figma-web/fetch",
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      },
      params: { buildId }
    }, log2);
  }
  fetchBuildInfo(requestData, ctx) {
    return this.request({
      url: `/fetchBuildInfo`,
      method: "GET",
      data: requestData
    }, ctx.log);
  }
  mergeBuildsByBuildId(requestData, ctx) {
    return this.request({
      url: `/mergeBuilds`,
      method: "POST",
      data: requestData
    }, ctx.log);
  }
  getSnapshotStatus(buildId, snapshotName, snapshotUuid, ctx) {
    return this.request({
      url: `/snapshot/status`,
      method: "GET",
      params: {
        buildId,
        snapshotName,
        snapshotUUID: snapshotUuid
      },
      headers: {
        "Content-Type": "application/json"
      }
    }, ctx.log);
  }
  getGeolocationProxy(geoLocation, log2) {
    return __async(this, null, function* () {
      try {
        const resp = yield this.request({
          url: "/geolocation",
          method: "GET",
          params: { geoLocation }
        }, log2);
        return resp;
      } catch (error) {
        this.handleHttpError(error, log2);
      }
    });
  }
  uploadPdf(ctx, form, buildName) {
    return __async(this, null, function* () {
      form.append("projectToken", this.projectToken);
      if (ctx.build.name !== void 0 && ctx.build.name !== "") {
        form.append("buildName", buildName);
      }
      if (ctx.options.markBaseline) {
        form.append("markBaseline", ctx.options.markBaseline.toString());
      }
      try {
        const response = yield this.axiosInstance.request({
          url: ctx.env.SMARTUI_UPLOAD_URL + "/pdf/upload",
          method: "POST",
          headers: form.getHeaders(),
          data: form
        });
        ctx.log.debug(`http response: ${JSON.stringify({
          status: response.status,
          headers: response.headers,
          body: response.data
        })}`);
        return response.data;
      } catch (error) {
        this.handleHttpError(error, ctx.log);
      }
    });
  }
  fetchPdfResults(ctx) {
    return __async(this, null, function* () {
      const params = {};
      if (ctx.build.projectId) {
        params.project_id = ctx.build.projectId;
      } else {
        throw new Error("Project ID not found to fetch PDF results");
      }
      params.build_id = ctx.build.id;
      const auth = Buffer.from(`${this.username}:${this.accessKey}`).toString("base64");
      try {
        const response = yield axios__default.default.request({
          url: ctx.env.SMARTUI_UPLOAD_URL + "/smartui/2.0/build/screenshots",
          method: "GET",
          params,
          headers: {
            "accept": "application/json",
            "Authorization": `Basic ${auth}`
          }
        });
        ctx.log.debug(`http response: ${JSON.stringify({
          status: response.status,
          headers: response.headers,
          body: response.data
        })}`);
        return response.data;
      } catch (error) {
        this.handleHttpError(error, ctx.log);
      }
    });
  }
};
var ctx_default = (options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  let env = env_default();
  let webConfig;
  let mobileConfig;
  let basicAuthObj;
  let tunnelObj;
  let config = constants_default.DEFAULT_CONFIG;
  let port;
  let resolutionOff;
  let extensionFiles;
  let ignoreStripExtension;
  let ignoreFilePattern;
  let parallelObj;
  let fetchResultObj;
  let fetchResultsFileObj;
  let buildNameObj;
  let allowDuplicateSnapshotNames = false;
  let useLambdaInternal = false;
  let useRemoteDiscovery = false;
  let useExtendedViewport = false;
  let loadDomContent = false;
  try {
    if (options.config) {
      config = JSON.parse(fs6__default.default.readFileSync(options.config, "utf-8"));
      if ((_a = config.web) == null ? void 0 : _a.resolutions) {
        config.web.viewports = config.web.resolutions;
        delete config.web.resolutions;
      }
      if (config.approvalThreshold && config.rejectionThreshold) {
        if (config.rejectionThreshold <= config.approvalThreshold) {
          throw new Error("Invalid config; rejectionThreshold must be greater than approvalThreshold");
        }
      }
      let validateConfigFn = options.scheduled ? validateConfigForScheduled : validateConfig;
      if (!validateConfigFn(config)) {
        throw new Error(validateConfigFn.errors[0].message);
      }
      if (config.customCSS) {
        try {
          config.customCSS = resolveCustomCSS(
            config.customCSS,
            options.config,
            logger_default
          );
          logger_default.debug("Successfully resolved and validated customCSS from config");
        } catch (error) {
          throw new Error(`customCSS error: ${error.message}`);
        }
      }
    } else {
      logger_default.info("## No config file provided. Using default config.");
    }
    port = parseInt(options.port || "49152", 10);
    if (isNaN(port) || port < 1 || port > 65535) {
      throw new Error("Invalid port number. Port number must be an integer between 1 and 65535.");
    }
    resolutionOff = options.ignoreResolutions || false;
    extensionFiles = options.files || ["png", "jpeg", "jpg"];
    ignoreStripExtension = options.removeExtensions || false;
    ignoreFilePattern = options.ignoreDir || [];
    parallelObj = options.parallel ? options.parallel === true ? 1 : options.parallel : 1;
    if (options.fetchResults) {
      if (options.fetchResults !== true && !options.fetchResults.endsWith(".json")) {
        console.error("Error: The file extension for --fetch-results must be .json");
        process.exit(1);
      }
      fetchResultObj = true;
      fetchResultsFileObj = options.fetchResults === true ? "" : options.fetchResults;
    } else {
      fetchResultObj = false;
      fetchResultsFileObj = "";
    }
    buildNameObj = options.buildName || "";
    if (options.userName && options.accessKey) {
      env.LT_USERNAME = options.userName;
      env.LT_ACCESS_KEY = options.accessKey;
    }
  } catch (error) {
    console.log(`[smartui] Error: ${error.message}`);
    process.exit(1);
  }
  if (config.web) {
    webConfig = { browsers: config.web.browsers, viewports: [] };
    for (let viewport of (_b = config.web) == null ? void 0 : _b.viewports)
      webConfig.viewports.push({ width: viewport[0], height: viewport[1] || 0 });
  }
  if (config.mobile) {
    mobileConfig = {
      devices: config.mobile.devices,
      fullPage: (_c = config.mobile.fullPage) != null ? _c : true,
      orientation: config.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT
    };
  }
  if (env.BASIC_AUTH_USERNAME && env.BASIC_AUTH_PASSWORD) {
    basicAuthObj = {
      "username": env.BASIC_AUTH_USERNAME,
      "password": env.BASIC_AUTH_PASSWORD
    };
  }
  if (config.basicAuthorization) {
    basicAuthObj = config.basicAuthorization;
  }
  if (config.tunnel) {
    tunnelObj = config.tunnel;
  }
  if (config.allowDuplicateSnapshotNames) {
    allowDuplicateSnapshotNames = true;
  }
  if (config.useLambdaInternal) {
    useLambdaInternal = true;
  }
  if (config.useRemoteDiscovery) {
    useRemoteDiscovery = true;
  }
  if (config.useExtendedViewport) {
    useExtendedViewport = true;
  }
  if (config.loadDomContent) {
    loadDomContent = true;
  }
  if (config.waitForPageRender && config.waitForPageRender < 3e4) {
    config.waitForPageRender = 3e4;
  }
  return {
    env,
    log: logger_default,
    client: new httpClient(env),
    config: {
      web: webConfig,
      mobile: mobileConfig,
      waitForPageRender: config.waitForPageRender || 0,
      waitForTimeout: config.waitForTimeout || 0,
      waitForDiscovery: config.waitForDiscovery || 3e4,
      enableJavaScript: (_d = config.enableJavaScript) != null ? _d : false,
      cliEnableJavaScript: (_e = config.cliEnableJavaScript) != null ? _e : true,
      scrollTime: config.scrollTime || constants_default.DEFAULT_SCROLL_TIME,
      allowedHostnames: config.allowedHostnames || [],
      allowedAssets: config.allowedAssets || [],
      basicAuthorization: basicAuthObj,
      smartIgnore: (_f = config.smartIgnore) != null ? _f : false,
      delayedUpload: (_g = config.delayedUpload) != null ? _g : false,
      useGlobalCache: (_h = config.useGlobalCache) != null ? _h : false,
      ignoreHTTPSErrors: (_i = config.ignoreHTTPSErrors) != null ? _i : false,
      skipBuildCreation: (_j = config.skipBuildCreation) != null ? _j : false,
      tunnel: tunnelObj,
      dedicatedProxyURL: config.dedicatedProxyURL || "",
      geolocation: config.geolocation || "",
      userAgent: config.userAgent || "",
      requestHeaders: config.requestHeaders || {},
      allowDuplicateSnapshotNames,
      useLambdaInternal,
      useRemoteDiscovery,
      useExtendedViewport,
      loadDomContent,
      approvalThreshold: config.approvalThreshold,
      rejectionThreshold: config.rejectionThreshold,
      showRenderErrors: (_k = config.showRenderErrors) != null ? _k : false,
      customCSS: config.customCSS
    },
    uploadFilePath: "",
    webStaticConfig: [],
    git: {
      branch: "",
      commitId: "",
      commitAuthor: "",
      commitMessage: "",
      githubURL: ""
    },
    build: {
      id: "",
      name: buildNameObj,
      baseline: false,
      url: ""
    },
    args: {},
    tunnelDetails: {
      tunnelPort: -1,
      tunnelHost: "",
      tunnelName: ""
    },
    options: {
      parallel: parallelObj,
      force: options.force ? true : false,
      markBaseline: options.markBaseline ? true : false,
      buildName: options.buildName || "",
      scheduled: options.scheduled || "",
      port,
      ignoreResolutions: resolutionOff,
      fileExtension: extensionFiles,
      stripExtension: ignoreStripExtension,
      ignorePattern: ignoreFilePattern,
      fetchResults: fetchResultObj,
      fetchResultsFileName: fetchResultsFileObj,
      baselineBranch: options.baselineBranch || "",
      baselineBuild: options.baselineBuild || "",
      githubURL: options.gitURL || options.githubURL || "",
      showRenderErrors: options.showRenderErrors ? true : false,
      userName: options.userName || "",
      accessKey: options.accessKey || ""
    },
    cliVersion: version,
    totalSnapshots: -1,
    isStartExec: false,
    isSnapshotCaptured: false,
    sessionCapabilitiesMap: /* @__PURE__ */ new Map(),
    buildToSnapshotCountMap: /* @__PURE__ */ new Map(),
    sessionIdToSnapshotNameMap: /* @__PURE__ */ new Map(),
    fetchResultsForBuild: new Array(),
    orgId: 0,
    userId: 0,
    mergeBranchSource: "",
    mergeBranchTarget: "",
    mergeBuildSource: "",
    mergeBuildTarget: "",
    mergeBuildSourceId: "",
    mergeBuildTargetId: "",
    mergeByBranch: false,
    mergeByBuild: false
  };
};

// src/lib/execCommandOptions.ts
var execCommandOptions_default = (ctx) => {
  if (ctx.args.execCommand && !ctx.options.userName && !ctx.options.accessKey) {
    for (const arg of ctx.args.execCommand) {
      if (arg.includes("lambdaTestUserName")) {
        ctx.env.LT_USERNAME = arg.split("=")[1];
      }
      if (arg.includes("lambdaTestAccessKey")) {
        ctx.env.LT_ACCESS_KEY = arg.split("=")[1];
      }
    }
  }
  return ctx;
};
function executeCommand(command11) {
  let dst = process.cwd();
  try {
    return child_process.execSync(command11, {
      cwd: dst,
      stdio: ["ignore"],
      encoding: "utf-8"
    });
  } catch (error) {
    throw new Error(error.message);
  }
}
function isGitRepo(ctx) {
  try {
    executeCommand("git status");
    return true;
  } catch (error) {
    setNonGitInfo(ctx);
    return false;
  }
}
var git_default = (ctx) => {
  if (ctx.env.SMART_GIT) {
    ctx.env.BASELINE_BRANCH = "";
    if (ctx.options.baselineBranch !== "") {
      ctx.env.SMART_GIT = false;
    }
  }
  let githubURL;
  if (ctx.options.githubURL && ctx.options.githubURL.startsWith("https://")) {
    githubURL = ctx.options.githubURL;
  }
  if (ctx.options.gitURL && ctx.options.gitURL.startsWith("https://")) {
    githubURL = ctx.options.gitURL;
  }
  if (ctx.env.SMARTUI_GIT_INFO_FILEPATH) {
    let gitInfo = JSON.parse(fs6__default.default.readFileSync(ctx.env.SMARTUI_GIT_INFO_FILEPATH, "utf-8"));
    if (ctx.options.markBaseline) {
      ctx.env.BASELINE_BRANCH = ctx.env.CURRENT_BRANCH || gitInfo.branch || "";
      ctx.env.SMART_GIT = false;
    }
    return {
      branch: ctx.env.CURRENT_BRANCH || gitInfo.branch || "",
      commitId: gitInfo.commit_id.slice(0, 6) || "",
      commitMessage: gitInfo.commit_body || "",
      commitAuthor: gitInfo.commit_author || "",
      githubURL: githubURL ? githubURL : ctx.env.GIT_URL ? ctx.env.GIT_URL : `${constants_default.GITHUB_API_HOST}/repos/${process.env.GITHUB_REPOSITORY}/statuses/${gitInfo.commit_id}`,
      baselineBranch: ctx.options.baselineBranch || ctx.env.BASELINE_BRANCH || ""
    };
  } else {
    const splitCharacter = "<##>";
    const prettyFormat = ["%h", "%H", "%s", "%f", "%b", "%at", "%ct", "%an", "%ae", "%cn", "%ce", "%N", ""];
    const command11 = 'git log -1 --pretty=format:"' + prettyFormat.join(splitCharacter) + '" && git rev-parse --abbrev-ref HEAD && git tag --contains HEAD';
    let res = executeCommand(command11).split(splitCharacter);
    var branchAndTags = res[res.length - 1].split("\n").filter((n) => n);
    var branch = ctx.env.CURRENT_BRANCH || branchAndTags[0];
    branchAndTags.slice(1);
    if (ctx.options.markBaseline) {
      ctx.env.BASELINE_BRANCH = branch || "";
      ctx.env.SMART_GIT = false;
    }
    return {
      branch: branch || "",
      commitId: res[0] || "",
      commitMessage: res[2] || "",
      commitAuthor: res[7] || "",
      githubURL: githubURL ? githubURL : ctx.env.GIT_URL ? ctx.env.GIT_URL : `${constants_default.GITHUB_API_HOST}/repos/${process.env.GITHUB_REPOSITORY}/statuses/${res[1]}`,
      baselineBranch: ctx.options.baselineBranch || ctx.env.BASELINE_BRANCH || ""
    };
  }
};
function setNonGitInfo(ctx) {
  let branch = ctx.env.CURRENT_BRANCH || "unknown-branch";
  if (ctx.options.markBaseline) {
    ctx.env.BASELINE_BRANCH = branch;
    ctx.env.SMART_GIT = false;
  }
  let githubURL;
  if (ctx.options.githubURL && ctx.options.githubURL.startsWith("https://")) {
    githubURL = ctx.options.githubURL;
  }
  if (ctx.options.gitURL && ctx.options.gitURL.startsWith("https://")) {
    githubURL = ctx.options.gitURL;
  }
  ctx.git = {
    branch,
    commitId: "-",
    commitAuthor: "-",
    commitMessage: "-",
    githubURL: githubURL ? githubURL : "",
    baselineBranch: ctx.options.baselineBranch || ctx.env.BASELINE_BRANCH || ""
  };
}
var getGitInfo_default = (ctx) => {
  return {
    title: `Fetching git repo details`,
    skip: (ctx2) => {
      return !isGitRepo(ctx2) && !ctx2.env.SMARTUI_GIT_INFO_FILEPATH ? "[SKIPPED] Fetching git repo details; not a git repo" : "";
    },
    task: (ctx2, task) => __async(void 0, null, function* () {
      if (ctx2.env.CURRENT_BRANCH && ctx2.env.CURRENT_BRANCH.trim() === "") {
        throw new Error("Error: The environment variable CURRENT_BRANCH cannot be empty.");
      }
      try {
        ctx2.git = git_default(ctx2);
        task.output = chalk__default.default.gray(`branch: ${ctx2.git.branch}, commit: ${ctx2.git.commitId}, author: ${ctx2.git.commitAuthor}`);
        if (ctx2.git.githubURL && ctx2.git.githubURL !== "") {
          task.output += chalk__default.default.gray(`, githubURL: ${ctx2.git.githubURL}`);
        }
        task.title = "Fetched git information";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Error fetching git repo details");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var createBuildExec_default = (ctx) => {
  return {
    title: `Creating SmartUI build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "createBuild" });
      try {
        if (ctx2.authenticatedInitially && !ctx2.config.skipBuildCreation) {
          let resp = yield ctx2.client.createBuild(ctx2.git, ctx2.config, ctx2.log, ctx2.build.name, ctx2.isStartExec, ctx2.env.SMART_GIT, ctx2.options.markBaseline, ctx2.options.baselineBuild, ctx2.options.scheduled, ctx2.env.LT_USERNAME, ctx2.env.LT_ACCESS_KEY);
          if (resp && resp.data && resp.data.buildId) {
            ctx2.build = {
              id: resp.data.buildId,
              name: resp.data.buildName,
              url: resp.data.buildURL,
              baseline: resp.data.baseline,
              useKafkaFlow: resp.data.useKafkaFlow || false,
              checkPendingRequests: resp.data.checkPendingRequests || false
            };
            process.env.SMARTUI_BUILD_ID = resp.data.buildId;
            process.env.SMARTUI_BUILD_NAME = resp.data.buildName;
          } else if (resp && resp.error) {
            if (resp.error.message) {
              ctx2.log.error(`Error while creation of build: ${resp.error.message}`);
              throw new Error(`Error while creation of build: ${resp.error.message}`);
            }
          }
          if (ctx2.build.id === "") {
            ctx2.log.debug("Build creation failed: Build ID is empty");
            task.output = chalk__default.default.red("Build creation failed: Build ID is empty");
            throw new Error("SmartUI build creation failed");
          }
          task.output = chalk__default.default.gray(`build id: ${resp.data.buildId}`);
          task.title = "SmartUI build created";
          if (ctx2.env.USE_REMOTE_DISCOVERY || ctx2.config.useRemoteDiscovery) {
            task.output += chalk__default.default.gray(`
 Using remote discovery for this build`);
          }
        } else {
          task.output = chalk__default.default.gray(`Empty PROJECT_TOKEN and PROJECT_NAME. Skipping Creation of Build!`);
          task.title = "Skipped SmartUI build creation";
        }
        if (ctx2.autoTunnelStarted) {
          if (ctx2.build && ctx2.build.id && ctx2.sourceCommand != "exec-start") {
            startPingPolling(ctx2);
          }
        }
        if (ctx2.config.tunnel) {
          let tunnelResp = yield ctx2.client.getTunnelDetails(ctx2, ctx2.log);
          ctx2.log.debug(`Tunnel Response: ${JSON.stringify(tunnelResp)}`);
          if (tunnelResp && tunnelResp.data && tunnelResp.data.host && tunnelResp.data.port && tunnelResp.data.tunnel_name) {
            ctx2.tunnelDetails = {
              tunnelHost: tunnelResp.data.host,
              tunnelPort: tunnelResp.data.port,
              tunnelName: tunnelResp.data.tunnel_name
            };
            ctx2.log.debug(`Tunnel Details: ${JSON.stringify(ctx2.tunnelDetails)}`);
            if (process.env.USE_REMOTE_DISCOVERY === void 0) {
              ctx2.env.USE_REMOTE_DISCOVERY = true;
              process.env.USE_REMOTE_DISCOVERY = "true";
              task.output += chalk__default.default.gray(`
 Using remote discovery by default for this build`);
            }
            ctx2.log.debug(`USE_REMOTE_DISCOVERY is set to ${ctx2.env.USE_REMOTE_DISCOVERY}`);
          } else if (tunnelResp && tunnelResp.error) {
            if (tunnelResp.error.message) {
              if (tunnelResp.error.code && tunnelResp.error.code === 400) {
                ctx2.log.warn(tunnelResp.error.message);
              } else {
                ctx2.log.warn(`Error while fetch tunnel details; Either tunnel is not running or tunnel parameters are different`);
              }
            }
          }
        }
      } catch (error) {
        ctx2.log.debug(error);
        if (ctx2.autoTunnelStarted) {
          yield stopTunnelHelper(ctx2);
        }
        task.output = chalk__default.default.gray(error.message);
        throw new Error("SmartUI build creation failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var exec_default = (ctx) => {
  var _a;
  return {
    title: `Executing '${(_a = ctx.args.execCommand) == null ? void 0 : _a.join(" ")}'`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      if (ctx2.options.fetchResults) {
        if (ctx2.build && ctx2.build.id) {
          startPolling(ctx2, "", false, "");
        }
      }
      if ((ctx2.env.SHOW_RENDER_ERRORS || ctx2.options.showRenderErrors || ctx2.config.showRenderErrors) && ctx2.build && ctx2.build.id) {
        if (ctx2.env.LT_USERNAME && ctx2.env.LT_ACCESS_KEY) {
          startSSEListener(ctx2);
        } else {
          ctx2.log.info("LT_USERNAME and LT_ACCESS_KEY are not set, set them to display render errors");
        }
      }
      updateLogContext({ task: "exec" });
      return new Promise((resolve, reject) => {
        var _a2, _b, _c, _d, _e;
        const childProcess = spawn__default.default(ctx2.args.execCommand[0], (_a2 = ctx2.args.execCommand) == null ? void 0 : _a2.slice(1));
        let totalOutput = "";
        if (!ctx2.env.LT_SDK_SKIP_EXECUTION_LOGS) {
          const output = listr2.createWritable((chunk) => {
            totalOutput += chunk;
            task.output = chalk__default.default.gray(totalOutput);
          });
          (_b = childProcess.stdout) == null ? void 0 : _b.pipe(output);
          (_c = childProcess.stderr) == null ? void 0 : _c.pipe(output);
        } else {
          const logFileName = `execution-logs.log`;
          const logFilePath = path3__default.default.join(process.cwd(), logFileName);
          const logStream = fs6__default.default.createWriteStream(logFilePath, { flags: "a" });
          task.output = chalk__default.default.gray(`Execution logs being written to: ${logFileName}`);
          (_d = childProcess.stdout) == null ? void 0 : _d.on("data", (data) => {
            logStream.write(data);
          });
          (_e = childProcess.stderr) == null ? void 0 : _e.on("data", (data) => {
            logStream.write(data);
          });
          childProcess.on("close", () => {
            logStream.end();
          });
        }
        childProcess.on("error", (error) => {
          var _a3;
          task.output = chalk__default.default.gray(`error: ${error.message}`);
          throw new Error(`Execution of '${(_a3 = ctx2.args.execCommand) == null ? void 0 : _a3.join(" ")}' failed`);
        });
        childProcess.on("close", (code, signal) => __async(void 0, null, function* () {
          var _a3;
          if (code !== null) {
            task.title = `Execution of '${(_a3 = ctx2.args.execCommand) == null ? void 0 : _a3.join(" ")}' completed; exited with code ${code}`;
            if (code !== 0) {
              process.exitCode = code;
            }
          } else if (signal !== null) {
            throw new Error(`Child process killed with signal ${signal}`);
          }
          resolve();
        }));
      });
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};
var processSnapshot_default = (ctx) => {
  return {
    title: `Processing snapshots`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a, _b, _c, _d;
      try {
        if (ctx2.config.delayedUpload) {
          ctx2.log.debug("started after processing because of delayedUpload");
          (_a = ctx2.snapshotQueue) == null ? void 0 : _a.startProcessingfunc();
        }
        yield new Promise((resolve) => {
          let output2 = "";
          const intervalId = setInterval(() => {
            var _a2, _b2, _c2;
            if (((_a2 = ctx2.snapshotQueue) == null ? void 0 : _a2.isEmpty()) && !((_b2 = ctx2.snapshotQueue) == null ? void 0 : _b2.isProcessing())) {
              clearInterval(intervalId);
              resolve();
            } else {
              task.title = `Processing snapshot ${(_c2 = ctx2.snapshotQueue) == null ? void 0 : _c2.getProcessingSnapshot()}`;
            }
          }, 500);
        });
        let output = "";
        for (let snapshot of (_b = ctx2.snapshotQueue) == null ? void 0 : _b.getProcessedSnapshots()) {
          if (snapshot.error) {
            output += `${chalk__default.default.red("\u2717")} ${chalk__default.default.gray(`${snapshot.name}
[error] ${snapshot.error}`)}
`;
            process.exitCode = 1;
          } else
            output += `${chalk__default.default.green("\u2713")} ${chalk__default.default.gray(snapshot.name)}
${snapshot.warnings.length ? chalk__default.default.gray(`[warning] ${snapshot.warnings.join("\n[warning] ")}
`) : ""}`;
        }
        task.output = output;
        task.title = "Processed snapshots";
        if (((_d = (_c = ctx2.snapshotQueue) == null ? void 0 : _c.getProcessedSnapshots()) == null ? void 0 : _d.length) === 0) {
          task.title = "No snapshots processed";
        }
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        process.exitCode = 1;
        throw new Error("Processing of snapshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var uploadDomToS3ViaEnv2 = process.env.USE_LAMBDA_INTERNAL || false;
var finalizeBuild_default = (ctx) => {
  return {
    title: `Finalizing build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      var _a, _b, _c;
      updateLogContext({ task: "finalizeBuild" });
      try {
        if (ctx2.build.id) {
          yield ctx2.client.finalizeBuild(ctx2.build.id, ctx2.totalSnapshots, ctx2.log);
        }
        if (ctx2.build.hasDiscoveryError) {
          ctx2.log.warn(`We found some network errors while capturing DOM snapshots. These network errors may cause visual differences in your screenshots. Please go to ${ctx2.build.url} for more details`);
        }
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Finalize build failed");
      }
      let buildUrls = `build url: ${ctx2.build.url}
`;
      if (pingIntervalId !== null) {
        clearInterval(pingIntervalId);
        ctx2.log.debug("Ping polling stopped immediately from Finalize Build");
      }
      let uploadedCliLogsBuildIds = /* @__PURE__ */ new Set();
      for (const [sessionId, capabilities] of ctx2.sessionCapabilitiesMap.entries()) {
        try {
          const buildId = (capabilities == null ? void 0 : capabilities.buildId) || "";
          const projectToken = (capabilities == null ? void 0 : capabilities.projectToken) || "";
          const totalSnapshots = (capabilities == null ? void 0 : capabilities.snapshotCount) || 0;
          const sessionBuildUrl = (capabilities == null ? void 0 : capabilities.buildURL) || "";
          const testId = (capabilities == null ? void 0 : capabilities.id) || "";
          if (ctx2.options.fetchResults && ctx2.fetchResultsForBuild) {
            if (!ctx2.fetchResultsForBuild.includes(buildId)) {
              let is_baseline;
              if (capabilities.baseline) {
                is_baseline = true;
              } else {
                is_baseline = false;
              }
              startPolling(ctx2, buildId, is_baseline, capabilities.projectToken);
              yield new Promise((resolve) => setTimeout(resolve, 7e3));
              ctx2.fetchResultsForBuild.push(buildId);
            }
          }
          ctx2.log.debug(`Capabilities for sessionId ${sessionId}: ${JSON.stringify(capabilities)}`);
          if (buildId && projectToken) {
            if (ctx2.isSnapshotCaptured && !uploadedCliLogsBuildIds.has(buildId)) {
              let uploadCLILogsToS3 = ctx2.config.useLambdaInternal || uploadDomToS3ViaEnv2;
              if (!uploadCLILogsToS3) {
                ctx2.log.debug(`Log file to be uploaded`);
                let resp = yield ctx2.client.getS3PreSignedURLForCaps(ctx2, buildId, projectToken);
                yield ctx2.client.uploadLogsForCaps(ctx2, resp.data.url);
              } else {
                ctx2.log.debug(`Log file to be uploaded via LSRS`);
                ctx2.client.sendCliLogsToLSRSForCaps(ctx2, buildId, projectToken);
              }
              uploadedCliLogsBuildIds.add(buildId);
            }
            yield ctx2.client.finalizeBuildForCapsWithToken(buildId, totalSnapshots, projectToken, ctx2.log);
            if (ctx2.autoTunnelStarted) {
              yield startPollingForTunnel(ctx2, buildId, false, projectToken, capabilities == null ? void 0 : capabilities.buildName);
            }
          }
          if (testId && buildId) {
            buildUrls += `TestId ${testId}: ${sessionBuildUrl}
`;
          }
        } catch (error) {
          ctx2.log.debug(`Error finalizing build for session ${sessionId}: ${error.message}`);
        }
      }
      task.output = chalk__default.default.gray(buildUrls);
      task.title = "Finalized build";
      if (ctx2.tunnelDetails && ctx2.tunnelDetails.tunnelHost != "" && ((_a = ctx2.build) == null ? void 0 : _a.id)) {
        yield startPollingForTunnel(ctx2, ctx2.build.id, false, "", "");
      }
      if (ctx2.autoTunnelStarted && isTunnelPolling === null) {
        yield stopTunnelHelper(ctx2);
      }
      try {
        yield (_b = ctx2.browser) == null ? void 0 : _b.close();
        ctx2.log.debug(`Closed browser`);
        yield (_c = ctx2.server) == null ? void 0 : _c.close();
        ctx2.log.debug(`Closed server`);
        if (ctx2.isSnapshotCaptured) {
          let uploadCLILogsToS3 = ctx2.config.useLambdaInternal || uploadDomToS3ViaEnv2;
          if (!uploadCLILogsToS3) {
            ctx2.log.debug(`Log file to be uploaded`);
            let resp = yield ctx2.client.getS3PreSignedURL(ctx2);
            yield ctx2.client.uploadLogs(ctx2, resp.data.url);
          } else {
            ctx2.log.debug(`Log file to be uploaded via LSRS`);
            let resp = ctx2.client.sendCliLogsToLSRS(ctx2);
          }
        }
        if (process.exitCode && process.exitCode !== 0) {
          ctx2.log.error(`Exiting process with code ${process.exitCode}`);
          task.output = chalk__default.default.gray(`Exiting process with code ${process.exitCode}`);
          task.title = "Build finalized with errors";
          throw new Error(`Process exited with code ${process.exitCode}`);
        }
      } catch (error) {
        ctx2.log.debug(error);
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var globalCache = new NodeCache__default.default({ stdTTL: 3600, checkperiod: 600 });
var MAX_RESOURCE_SIZE = 15 * 1024 ** 2;
var ALLOWED_RESOURCES = ["document", "stylesheet", "image", "media", "font", "other"];
var ALLOWED_STATUSES = [200, 201];
var REQUEST_TIMEOUT = 18e4;
var MIN_VIEWPORT_HEIGHT = 1080;
var MAX_WAIT_FOR_REQUEST_CALL = 3e4;
var normalizeSameSite = (value) => {
  if (!value)
    return "Lax";
  const normalized = value.trim().toLowerCase();
  const mapping = {
    "lax": "Lax",
    "strict": "Strict",
    "none": "None"
  };
  return mapping[normalized] || value;
};
function prepareSnapshot(snapshot, ctx) {
  return __async(this, null, function* () {
    let processedOptions = {};
    processedOptions.cliEnableJavascript = ctx.config.cliEnableJavaScript;
    processedOptions.ignoreHTTPSErrors = ctx.config.ignoreHTTPSErrors;
    if (ctx.config.basicAuthorization) {
      processedOptions.basicAuthorization = ctx.config.basicAuthorization;
    }
    if (ctx.config.requestHeaders && Array.isArray(ctx.config.requestHeaders)) {
      processedOptions.requestHeaders = ctx.config.requestHeaders;
    }
    ctx.config.allowedHostnames.push(new URL(snapshot.url).hostname);
    processedOptions.allowedHostnames = ctx.config.allowedHostnames;
    processedOptions.skipCapturedCookies = ctx.env.SMARTUI_DO_NOT_USE_CAPTURED_COOKIES;
    if (ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY)
      processedOptions.proxy = { server: ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY };
    if (ctx.env.SMARTUI_HTTP_PROXY || ctx.env.SMARTUI_HTTPS_PROXY)
      processedOptions.proxy = { server: ctx.env.SMARTUI_HTTP_PROXY || ctx.env.SMARTUI_HTTPS_PROXY };
    let options = snapshot.options;
    let optionWarnings = /* @__PURE__ */ new Set();
    let selectors = [];
    let ignoreOrSelectDOM;
    if (options && Object.keys(options).length) {
      ctx.log.debug(`Snapshot options: ${JSON.stringify(options)}`);
      const isNotAllEmpty = (obj) => {
        var _a;
        for (let key in obj)
          if ((_a = obj[key]) == null ? void 0 : _a.length)
            return true;
        return false;
      };
      if (options.loadDomContent) {
        processedOptions.loadDomContent = true;
      }
      if (options.useExtendedViewport) {
        processedOptions.useExtendedViewport = true;
      }
      if (options.sessionId) {
        const sessionId = options.sessionId;
        processedOptions.sessionId = sessionId;
        if (ctx.sessionCapabilitiesMap && ctx.sessionCapabilitiesMap.has(sessionId)) {
          const sessionCapabilities = ctx.sessionCapabilitiesMap.get(sessionId);
          if (sessionCapabilities && sessionCapabilities.id) {
            processedOptions.testId = sessionCapabilities.id;
          }
        }
      }
      if (options.web && Object.keys(options.web).length) {
        processedOptions.web = {};
        if (options.web.viewports && options.web.viewports.length > 0) {
          processedOptions.web.viewports = options.web.viewports.filter(
            (viewport) => Array.isArray(viewport) && viewport.length > 0
          );
        }
        if (options.web.browsers && options.web.browsers.length > 0) {
          processedOptions.web.browsers = options.web.browsers;
        }
      }
      if (options.mobile && Object.keys(options.mobile).length) {
        processedOptions.mobile = {};
        if (options.mobile.devices && options.mobile.devices.length > 0) {
          processedOptions.mobile.devices = options.mobile.devices;
        }
        if (options.mobile.hasOwnProperty("fullPage") && typeof options.mobile.fullPage === "boolean") {
          processedOptions.mobile.fullPage = options.mobile.fullPage;
        } else {
          processedOptions.mobile.fullPage = true;
        }
        if (options.mobile.hasOwnProperty("orientation") && (options.mobile.orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT || options.mobile.orientation === constants_default.MOBILE_ORIENTATION_LANDSCAPE)) {
          processedOptions.mobile.orientation = options.mobile.orientation;
        } else {
          processedOptions.mobile.orientation = constants_default.MOBILE_ORIENTATION_PORTRAIT;
        }
      }
      if (options.element && Object.keys(options.element).length) {
        if (options.element.id)
          processedOptions.element = "#" + options.element.id;
        else if (options.element.class)
          processedOptions.element = "." + options.element.class;
        else if (options.element.cssSelector)
          processedOptions.element = options.element.cssSelector;
        else if (options.element.xpath)
          processedOptions.element = "xpath=" + options.element.xpath;
      } else if (options.ignoreDOM && Object.keys(options.ignoreDOM).length && isNotAllEmpty(options.ignoreDOM)) {
        processedOptions.ignoreBoxes = {};
        ignoreOrSelectDOM = "ignoreDOM";
      } else if (options.selectDOM && Object.keys(options.selectDOM).length && isNotAllEmpty(options.selectDOM)) {
        processedOptions.selectBoxes = {};
        ignoreOrSelectDOM = "selectDOM";
      }
      if (ignoreOrSelectDOM) {
        for (const [key, value] of Object.entries(options[ignoreOrSelectDOM])) {
          switch (key) {
            case "id":
              selectors.push(...value.map((e) => "#" + e));
              break;
            case "class":
              selectors.push(...value.map((e) => "." + e));
              break;
            case "xpath":
              selectors.push(...value.map((e) => "xpath=" + e));
              break;
            case "cssSelector":
              selectors.push(...value);
              break;
            case "coordinates":
              selectors.push(...value.map((e) => `coordinates=${e}`));
              break;
          }
        }
      }
      if (options.ignoreType) {
        processedOptions.ignoreType = options.ignoreType;
      }
    }
    if (ctx.config.tunnel) {
      if (ctx.tunnelDetails && ctx.tunnelDetails.tunnelPort != -1 && ctx.tunnelDetails.tunnelHost != "") {
        const tunnelAddress = `http://${ctx.tunnelDetails.tunnelHost}:${ctx.tunnelDetails.tunnelPort}`;
        processedOptions.tunnelAddress = tunnelAddress;
        ctx.log.debug(`Tunnel address added to processedOptions: ${tunnelAddress}`);
      }
    }
    if (ctx.config.loadDomContent) {
      processedOptions.loadDomContent = true;
    }
    if (ctx.config.useExtendedViewport) {
      processedOptions.useExtendedViewport = true;
    }
    try {
      if (options == null ? void 0 : options.customCSS) {
        const resolvedCSS = resolveCustomCSS(options.customCSS, "", ctx.log);
        processedOptions.customCSS = resolvedCSS;
        ctx.log.debug("Using per-snapshot customCSS (overriding config)");
      } else if (ctx.config.customCSS) {
        processedOptions.customCSS = ctx.config.customCSS;
        ctx.log.debug("Using config customCSS");
      }
    } catch (error) {
      ctx.log.warn(`customCSS warning: ${error.message}`);
      chalk__default.default.yellow(`[SmartUI] warning: ${error.message}`);
    }
    processedOptions.allowedAssets = ctx.config.allowedAssets;
    processedOptions.selectors = selectors;
    processedOptions.ignoreDOM = options == null ? void 0 : options.ignoreDOM;
    processedOptions.selectDOM = options == null ? void 0 : options.selectDOM;
    ctx.log.debug(`Processed options: ${JSON.stringify(processedOptions)}`);
    let renderViewports;
    if (snapshot.options && snapshot.options.web || snapshot.options && snapshot.options.mobile) {
      renderViewports = getRenderViewportsForOptions(snapshot.options);
    } else {
      renderViewports = getRenderViewports(ctx);
    }
    processedOptions.doRemoteDiscovery = true;
    return {
      processedSnapshot: {
        name: snapshot.name,
        url: snapshot.url,
        dom: Buffer.from(snapshot.dom.html).toString("base64"),
        resources: {},
        options: processedOptions,
        cookies: Buffer.from(snapshot.dom.cookies).toString("base64"),
        renderViewports
      },
      warnings: [...optionWarnings, ...snapshot.dom.warnings]
    };
  });
}
function processSnapshot(snapshot, ctx) {
  return __async(this, null, function* () {
    var _a, _b;
    updateLogContext({ task: "discovery" });
    ctx.log.debug(`Processing snapshot ${snapshot.name} ${snapshot.url}`);
    const isHeadless = ((_a = process.env.HEADLESS) == null ? void 0 : _a.toLowerCase()) === "false" ? false : true;
    let discoveryErrors = {
      name: "",
      url: "",
      timestamp: "",
      snapshotUUID: "",
      browsers: {}
    };
    let processedOptions = {};
    if (ctx.config.requestHeaders && Array.isArray(ctx.config.requestHeaders)) {
      processedOptions.requestHeaders = ctx.config.requestHeaders;
    }
    let globalViewport = "";
    let globalBrowser = constants_default.CHROME;
    let launchOptions = {
      headless: isHeadless,
      args: constants_default.LAUNCH_ARGS
    };
    let contextOptions = {
      javaScriptEnabled: ctx.config.cliEnableJavaScript,
      ignoreHTTPSErrors: ctx.config.ignoreHTTPSErrors
    };
    if (!ctx.env.DO_NOT_USE_USER_AGENT) {
      contextOptions.userAgent = constants_default.CHROME_USER_AGENT;
    }
    if (!((_b = ctx.browser) == null ? void 0 : _b.isConnected())) {
      if (ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY)
        launchOptions.proxy = { server: ctx.env.HTTP_PROXY || ctx.env.HTTPS_PROXY };
      if (ctx.env.SMARTUI_HTTP_PROXY || ctx.env.SMARTUI_HTTPS_PROXY)
        launchOptions.proxy = { server: ctx.env.SMARTUI_HTTP_PROXY || ctx.env.SMARTUI_HTTPS_PROXY };
      ctx.browser = yield test.chromium.launch(launchOptions);
      ctx.log.debug(`Chromium launched with options ${JSON.stringify(launchOptions)}`);
    }
    const context = yield ctx.browser.newContext(contextOptions);
    ctx.log.debug(`Browser context created with options ${JSON.stringify(contextOptions)}`);
    if (!ctx.env.SMARTUI_DO_NOT_USE_CAPTURED_COOKIES && snapshot.dom.cookies) {
      const domainName = new URL(snapshot.url).hostname;
      ctx.log.debug(`Setting cookies for domain: ${domainName}`);
      const cookieArray = snapshot.dom.cookies.split("; ").map((cookie) => {
        if (!cookie)
          return null;
        const [name, value] = cookie.split("=");
        if (!name || !value)
          return null;
        return {
          name: name.trim(),
          value: value.trim(),
          domain: domainName,
          path: "/"
        };
      }).filter(Boolean);
      if (cookieArray.length > 0) {
        yield context.addCookies(cookieArray);
      } else {
        ctx.log.debug("No valid cookies to add");
      }
    }
    let options = snapshot.options;
    if ((options == null ? void 0 : options.customCookies) && Array.isArray(options.customCookies) && options.customCookies.length > 0) {
      ctx.log.debug(`Setting ${options.customCookies.length} custom cookies`);
      const validCustomCookies = options.customCookies.filter((cookie) => {
        if (!cookie.name || !cookie.value || !cookie.domain) {
          ctx.log.debug(`Skipping invalid custom cookie: missing required fields (name, value, or domain)`);
          return false;
        }
        const sameSiteValue = normalizeSameSite(cookie.sameSite);
        if (!["Strict", "Lax", "None"].includes(sameSiteValue)) {
          ctx.log.debug(`Skipping invalid custom cookie: invalid sameSite value '${cookie.sameSite}'`);
          return false;
        }
        return true;
      }).map((cookie) => ({
        name: cookie.name,
        value: cookie.value,
        domain: cookie.domain,
        path: cookie.path || "/",
        httpOnly: cookie.httpOnly || false,
        secure: cookie.secure || false,
        sameSite: normalizeSameSite(cookie.sameSite)
      }));
      if (validCustomCookies.length > 0) {
        try {
          yield context.addCookies(validCustomCookies);
          ctx.log.debug(`Successfully added ${validCustomCookies.length} custom cookies`);
        } catch (error) {
          ctx.log.debug(`Failed to add custom cookies: ${error}`);
        }
      } else {
        ctx.log.debug("No valid custom cookies to add");
      }
    }
    const page = yield context.newPage();
    let cache = {};
    if (snapshot.dom.resources.length) {
      for (let resource of snapshot.dom.resources) {
        let body = resource.mimetype == "text/css" ? Buffer.from(resource.content).toString("base64") : resource.content;
        cache[resource.url] = {
          body,
          type: resource.mimetype
        };
      }
    }
    const pendingRequests = /* @__PURE__ */ new Set();
    yield page.route("**/*", (route, request) => __async(this, null, function* () {
      var _a2;
      const requestUrl = request.url();
      const requestHostname = new URL(requestUrl).hostname;
      let requestOptions = {
        timeout: REQUEST_TIMEOUT,
        headers: __spreadValues(__spreadValues({}, yield request.allHeaders()), constants_default.REQUEST_HEADERS)
      };
      try {
        if (/\.(mp3|mp4|wav|ogg|webm)$/i.test(request.url())) {
          throw new Error("resource type mp3/mp4/wav/ogg/webm");
        }
        ctx.config.allowedHostnames.push(new URL(snapshot.url).hostname);
        if (ctx.config.enableJavaScript)
          ALLOWED_RESOURCES.push("script");
        if (ctx.config.basicAuthorization) {
          ctx.log.debug(`Adding basic authorization to the headers for root url`);
          let token = Buffer.from(`${ctx.config.basicAuthorization.username}:${ctx.config.basicAuthorization.password}`).toString("base64");
          requestOptions.headers.Authorization = `Basic ${token}`;
        }
        if (ctx.config.requestHeaders && Array.isArray(ctx.config.requestHeaders)) {
          ctx.config.requestHeaders.forEach((headerObj) => {
            Object.entries(headerObj).forEach(([key, value]) => {
              requestOptions.headers[key] = value;
            });
          });
        }
        let response, body;
        if (requestUrl === snapshot.url) {
          response = {
            status: () => 200,
            headers: () => ({ "content-type": "text/html" })
          };
          body = snapshot.dom.html;
        } else if (cache[requestUrl]) {
          response = {
            status: () => 200,
            headers: () => ({ "content-type": cache[requestUrl].mimetype })
          };
          body = cache[requestUrl].body;
        } else if (ctx.config.useGlobalCache && globalCache.has(requestUrl)) {
          ctx.log.debug(`Found resource ${requestUrl} in global cache`);
          response = {
            status: () => 200,
            headers: () => ({ "content-type": globalCache.get(requestUrl).type })
          };
          body = globalCache.get(requestUrl).body;
        } else {
          ctx.log.debug(`Resource not found in cache or global cache ${requestUrl} fetching from server`);
          if (ctx.build.checkPendingRequests) {
            pendingRequests.add(requestUrl);
          }
          response = yield page.request.fetch(request, requestOptions);
          body = yield response.body();
          if (ctx.build.checkPendingRequests) {
            pendingRequests.delete(requestUrl);
          }
        }
        if (!body) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping no response`);
        } else if (!body.length) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping empty response`);
        } else if (requestUrl === snapshot.url) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping root resource`);
        } else if (!ctx.config.allowedHostnames.includes(requestHostname)) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping remote resource`);
        } else if (cache[requestUrl]) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping already cached resource`);
        } else if (body.length > MAX_RESOURCE_SIZE) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping resource larger than 15MB`);
        } else if (!ALLOWED_RESOURCES.includes(request.resourceType())) {
          ctx.log.debug(`Handling request ${requestUrl}
 - skipping disallowed resource type [${request.resourceType()}]`);
        } else if (!ALLOWED_STATUSES.includes(response.status())) {
          ctx.log.debug(`${globalViewport} Handling request ${requestUrl}
 - skipping disallowed status [${response.status()}]`);
          if (response && response.headers()) {
            const responseHeaders = response.headers();
            ctx.log.debug(`Response headers for ${requestUrl}: ${JSON.stringify(responseHeaders, null, 2)}`);
          }
          let responseOfRetry, bodyOfRetry;
          ctx.log.debug(`Resource had a disallowed status ${requestUrl} fetching from server again`);
          if (ctx.build.checkPendingRequests) {
            pendingRequests.add(requestUrl);
          }
          responseOfRetry = yield page.request.fetch(request, requestOptions);
          bodyOfRetry = yield responseOfRetry.body();
          if (ctx.build.checkPendingRequests) {
            pendingRequests.delete(requestUrl);
          }
          if (responseOfRetry && responseOfRetry.status() && ALLOWED_STATUSES.includes(responseOfRetry.status())) {
            ctx.log.debug(`Handling request after retry ${requestUrl}
 - content-type ${responseOfRetry.headers()["content-type"]}`);
            cache[requestUrl] = {
              body: bodyOfRetry.toString("base64"),
              type: responseOfRetry.headers()["content-type"]
            };
            if (ctx.config.useGlobalCache) {
              globalCache.set(requestUrl, {
                body: bodyOfRetry.toString("base64"),
                type: responseOfRetry.headers()["content-type"]
              });
            }
            route.fulfill({
              status: responseOfRetry.status(),
              headers: responseOfRetry.headers(),
              body: bodyOfRetry
            });
          } else {
            ctx.log.debug(`Resource had a disallowed status for retry as well  ${requestUrl} disallowed status [${responseOfRetry.status()}]`);
            if (responseOfRetry && responseOfRetry.headers()) {
              const responseHeadersRetry = responseOfRetry.headers();
              ctx.log.debug(`Response headers for retry ${requestUrl}: ${JSON.stringify(responseHeadersRetry, null, 2)}`);
            }
            let data = {
              statusCode: `${responseOfRetry.status()}`,
              url: requestUrl,
              resourceType: request.resourceType()
            };
            if (response.status() >= 400 && response.status() < 600 && response.status() !== 0) {
              if (!discoveryErrors.browsers[globalBrowser]) {
                discoveryErrors.browsers[globalBrowser] = {};
              }
              if (discoveryErrors.browsers[globalBrowser] && !discoveryErrors.browsers[globalBrowser][globalViewport]) {
                discoveryErrors.browsers[globalBrowser][globalViewport] = [];
              }
              if (discoveryErrors.browsers[globalBrowser]) {
                (_a2 = discoveryErrors.browsers[globalBrowser][globalViewport]) == null ? void 0 : _a2.push(data);
              }
            }
          }
        } else {
          ctx.log.debug(`Handling request ${requestUrl}
 - content-type ${response.headers()["content-type"]}`);
          if (ctx.config.useGlobalCache) {
            globalCache.set(requestUrl, {
              body: body.toString("base64"),
              type: response.headers()["content-type"]
            });
          }
          cache[requestUrl] = {
            body: body.toString("base64"),
            type: response.headers()["content-type"]
          };
        }
        route.fulfill({
          status: response.status(),
          headers: response.headers(),
          body
        });
      } catch (error) {
        ctx.log.debug(`Handling request ${requestUrl}
 - aborted due to ${error.message}`);
        route.abort();
      }
    }));
    let optionWarnings = /* @__PURE__ */ new Set();
    let selectors = [];
    let ignoreOrSelectDOM;
    let ignoreOrSelectBoxes;
    if (options && Object.keys(options).length) {
      ctx.log.debug(`Snapshot options: ${JSON.stringify(options)}`);
      const isNotAllEmpty = (obj) => {
        var _a2;
        for (let key in obj)
          if ((_a2 = obj[key]) == null ? void 0 : _a2.length)
            return true;
        return false;
      };
      if (options.loadDomContent) {
        processedOptions.loadDomContent = true;
      }
      if (options.sessionId) {
        const sessionId = options.sessionId;
        processedOptions.sessionId = sessionId;
        if (ctx.sessionCapabilitiesMap && ctx.sessionCapabilitiesMap.has(sessionId)) {
          const sessionCapabilities = ctx.sessionCapabilitiesMap.get(sessionId);
          if (sessionCapabilities && sessionCapabilities.id) {
            processedOptions.testId = sessionCapabilities.id;
          }
        }
      }
      if (options.web && Object.keys(options.web).length) {
        processedOptions.web = {};
        if (options.web.viewports && options.web.viewports.length > 0) {
          processedOptions.web.viewports = options.web.viewports.filter(
            (viewport) => Array.isArray(viewport) && viewport.length > 0
          );
        }
        if (options.web.browsers && options.web.browsers.length > 0) {
          processedOptions.web.browsers = options.web.browsers;
        }
      }
      if (options.mobile && Object.keys(options.mobile).length) {
        processedOptions.mobile = {};
        if (options.mobile.devices && options.mobile.devices.length > 0) {
          processedOptions.mobile.devices = options.mobile.devices;
        }
        if (options.mobile.hasOwnProperty("fullPage") && typeof options.mobile.fullPage === "boolean") {
          processedOptions.mobile.fullPage = options.mobile.fullPage;
        } else {
          processedOptions.mobile.fullPage = true;
        }
        if (options.mobile.hasOwnProperty("orientation") && (options.mobile.orientation === constants_default.MOBILE_ORIENTATION_PORTRAIT || options.mobile.orientation === constants_default.MOBILE_ORIENTATION_LANDSCAPE)) {
          processedOptions.mobile.orientation = options.mobile.orientation;
        } else {
          processedOptions.mobile.orientation = constants_default.MOBILE_ORIENTATION_PORTRAIT;
        }
      }
      if (options.element && Object.keys(options.element).length) {
        if (options.element.id)
          processedOptions.element = "#" + options.element.id;
        else if (options.element.class)
          processedOptions.element = "." + options.element.class;
        else if (options.element.cssSelector)
          processedOptions.element = options.element.cssSelector;
        else if (options.element.xpath)
          processedOptions.element = "xpath=" + options.element.xpath;
      } else if (options.ignoreDOM && Object.keys(options.ignoreDOM).length && isNotAllEmpty(options.ignoreDOM)) {
        processedOptions.ignoreBoxes = {};
        ignoreOrSelectDOM = "ignoreDOM";
        ignoreOrSelectBoxes = "ignoreBoxes";
      } else if (options.selectDOM && Object.keys(options.selectDOM).length && isNotAllEmpty(options.selectDOM)) {
        processedOptions.selectBoxes = {};
        ignoreOrSelectDOM = "selectDOM";
        ignoreOrSelectBoxes = "selectBoxes";
      }
      if (ignoreOrSelectDOM) {
        for (const [key, value] of Object.entries(options[ignoreOrSelectDOM])) {
          switch (key) {
            case "id":
              selectors.push(...value.map((e) => e.startsWith("#") ? e : "#" + e));
              break;
            case "class":
              selectors.push(...value.map((e) => e.startsWith(".") ? e : "." + e));
              break;
            case "xpath":
              selectors.push(...value.map((e) => e.startsWith("xpath=") ? e : "xpath=" + e));
              break;
            case "cssSelector":
              selectors.push(...value);
              break;
            case "coordinates":
              selectors.push(...value.map((e) => `coordinates=${e}`));
              break;
          }
        }
      }
      if (options.ignoreType) {
        processedOptions.ignoreType = options.ignoreType;
      }
    }
    if (ctx.config.tunnel) {
      if (ctx.tunnelDetails && ctx.tunnelDetails.tunnelPort != -1 && ctx.tunnelDetails.tunnelHost != "") {
        const tunnelAddress = `http://${ctx.tunnelDetails.tunnelHost}:${ctx.tunnelDetails.tunnelPort}`;
        processedOptions.tunnelAddress = tunnelAddress;
        ctx.log.debug(`Tunnel address added to processedOptions: ${tunnelAddress}`);
      }
    }
    if (ctx.config.loadDomContent) {
      processedOptions.loadDomContent = true;
    }
    if (ctx.config.useExtendedViewport) {
      processedOptions.useExtendedViewport = true;
    }
    try {
      if (options == null ? void 0 : options.customCSS) {
        const resolvedCSS = resolveCustomCSS(options.customCSS, "", ctx.log);
        processedOptions.customCSS = resolvedCSS;
      } else if (ctx.config.customCSS) {
        processedOptions.customCSS = ctx.config.customCSS;
      }
    } catch (error) {
      optionWarnings.add(`${error.message}`);
    }
    ctx.log.debug(`Processed options: ${JSON.stringify(processedOptions)}`);
    let navigated = false;
    let previousDeviceType = null;
    let renderViewports;
    if (snapshot.options && snapshot.options.web || snapshot.options && snapshot.options.mobile) {
      renderViewports = getRenderViewportsForOptions(snapshot.options);
    } else {
      renderViewports = getRenderViewports(ctx);
    }
    for (const { viewport, viewportString, fullPage, device } of renderViewports) {
      if (previousDeviceType !== null && previousDeviceType !== device) {
        navigated = false;
      }
      previousDeviceType = device;
      yield page.setViewportSize({ width: viewport.width, height: viewport.height || MIN_VIEWPORT_HEIGHT });
      ctx.log.debug(`Page resized to ${viewport.width}x${viewport.height || MIN_VIEWPORT_HEIGHT}`);
      globalViewport = viewportString;
      ctx.log.debug(`globalViewport : ${globalViewport}`);
      if (globalViewport.toLowerCase().includes("iphone") || globalViewport.toLowerCase().includes("ipad")) {
        globalBrowser = constants_default.WEBKIT;
      } else {
        globalBrowser = constants_default.CHROME;
      }
      if (!navigated) {
        try {
          discoveryErrors.url = snapshot.url;
          discoveryErrors.name = snapshot.name;
          yield page.goto(snapshot.url, { waitUntil: "domcontentloaded", timeout: ctx.config.waitForDiscovery });
          yield new Promise((r) => setTimeout(r, 1250));
          if (ctx.config.waitForTimeout)
            yield page.waitForTimeout(ctx.config.waitForTimeout);
          yield page.waitForLoadState("networkidle", { timeout: 1e4 }).catch(() => {
            ctx.log.debug("networkidle event failed to fire within 10s");
          });
          navigated = true;
          ctx.log.debug(`Navigated to ${snapshot.url}`);
        } catch (error) {
          ctx.log.debug(`Navigation to discovery page failed; ${error}`);
          if (error && error.name && error.name === "TimeoutError") {
            ctx.log.debug(`Payload uploaded tough navigation to discovery page failed; ${error}`);
            return {
              processedSnapshot: {
                name: snapshot.name,
                url: snapshot.url,
                dom: Buffer.from(snapshot.dom.html).toString("base64"),
                resources: cache,
                options: processedOptions
              },
              warnings: [...optionWarnings, ...snapshot.dom.warnings]
            };
          }
        }
      }
      if (ctx.config.cliEnableJavaScript && fullPage)
        yield page.evaluate(scrollToBottomAndBackToTop, { frequency: 100, timing: ctx.config.scrollTime });
      try {
        yield page.waitForLoadState("networkidle", { timeout: 15e3 });
        ctx.log.debug("Network idle 500ms");
      } catch (error) {
        ctx.log.debug(`Network idle failed due to ${error}`);
      }
      if (ctx.config.allowedAssets && ctx.config.allowedAssets.length) {
        for (let assetUrl of ctx.config.allowedAssets) {
          if (!cache[assetUrl]) {
            ctx.log.debug(`Fetching asset ${assetUrl} from allowedAssets array`);
            try {
              const response = yield page.request.fetch(assetUrl, {
                timeout: 25e3,
                headers: __spreadValues({}, constants_default.REQUEST_HEADERS)
              });
              const body = yield response.body();
              if (body && body.length) {
                ctx.log.debug(`Caching asset ${assetUrl}`);
                cache[assetUrl] = {
                  body: body.toString("base64"),
                  type: response.headers()["content-type"]
                };
              } else {
                ctx.log.debug(`Asset ${assetUrl} returned empty or invalid body`);
              }
            } catch (error) {
              if (error && error.message) {
                ctx.log.debug(`Error fetching asset with error message ${assetUrl}: ${error.message}`);
              }
              ctx.log.debug(`Error fetching asset ${assetUrl}: ${JSON.stringify(error)}`);
            }
          } else {
            ctx.log.debug(`Asset ${assetUrl} already cached`);
          }
        }
      }
      if (selectors.length) {
        let height = 0;
        height = yield page.evaluate(() => {
          const DEFAULT_HEIGHT = 16384;
          const body = document.body;
          const html = document.documentElement;
          if (!body || !html) {
            ctx.log.debug("Document body or html element is missing, using default height");
            return DEFAULT_HEIGHT;
          }
          const measurements = [
            (body == null ? void 0 : body.scrollHeight) || 0,
            (body == null ? void 0 : body.offsetHeight) || 0,
            (html == null ? void 0 : html.clientHeight) || 0,
            (html == null ? void 0 : html.scrollHeight) || 0,
            (html == null ? void 0 : html.offsetHeight) || 0
          ];
          const allMeasurementsInvalid = measurements.every((measurement) => !measurement);
          if (allMeasurementsInvalid) {
            ctx.log.debug("All height measurements are invalid, using default height");
            return DEFAULT_HEIGHT;
          }
          return Math.max(...measurements);
        });
        ctx.log.debug(`Calculated content height: ${height}`);
        if (!Array.isArray(processedOptions[ignoreOrSelectBoxes][viewportString]))
          processedOptions[ignoreOrSelectBoxes][viewportString] = [];
        for (const selector of selectors) {
          if (selector.startsWith("coordinates=")) {
            const coordString = selector.replace("coordinates=", "");
            let pageHeight = height;
            if (viewport.height) {
              pageHeight = viewport.height;
            }
            const validation = validateCoordinates(
              coordString,
              pageHeight,
              viewport.width,
              snapshot.name
            );
            if (!validation.valid) {
              optionWarnings.add(validation.error);
              continue;
            }
            if (renderViewports.length > 1) {
              optionWarnings.add(`for snapshot ${snapshot.name} viewport ${viewportString}, coordinates may not be accurate for multiple viewports`);
            }
            __spreadValues({
              type: "coordinates"
            }, validation.coords);
            continue;
          } else {
            const isXPath = selector.startsWith("xpath=");
            const selectorValue = isXPath ? selector.substring(6) : selector;
            const boxes = yield page.evaluate(({ selectorValue: selectorValue2, isXPath: isXPath2 }) => {
              try {
                const DEFAULT_HEIGHT = 16384;
                const DEFAULT_WIDTH = 7680;
                const body = document.body;
                const html = document.documentElement;
                let pageHeight;
                let pageWidth;
                if (!body || !html) {
                  pageHeight = DEFAULT_HEIGHT;
                  pageWidth = DEFAULT_WIDTH;
                } else {
                  const measurements = [
                    (body == null ? void 0 : body.scrollHeight) || 0,
                    (body == null ? void 0 : body.offsetHeight) || 0,
                    (html == null ? void 0 : html.clientHeight) || 0,
                    (html == null ? void 0 : html.scrollHeight) || 0,
                    (html == null ? void 0 : html.offsetHeight) || 0
                  ];
                  const allMeasurementsInvalid = measurements.every((measurement) => !measurement);
                  if (allMeasurementsInvalid) {
                    pageHeight = DEFAULT_HEIGHT;
                  } else {
                    pageHeight = Math.max(...measurements);
                  }
                  const measurementsWidth = [
                    (body == null ? void 0 : body.scrollWidth) || 0,
                    (body == null ? void 0 : body.offsetWidth) || 0,
                    (html == null ? void 0 : html.clientWidth) || 0,
                    (html == null ? void 0 : html.scrollWidth) || 0,
                    (html == null ? void 0 : html.offsetWidth) || 0
                  ];
                  const allMeasurementsInvalidWidth = measurementsWidth.every((measurement) => !measurement);
                  if (allMeasurementsInvalidWidth) {
                    pageWidth = DEFAULT_WIDTH;
                  } else {
                    pageWidth = Math.max(...measurementsWidth);
                  }
                }
                let elements = [];
                if (isXPath2) {
                  const xpathResult = document.evaluate(
                    selectorValue2,
                    document,
                    null,
                    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
                    null
                  );
                  for (let i = 0; i < xpathResult.snapshotLength; i++) {
                    elements.push(xpathResult.snapshotItem(i));
                  }
                } else {
                  elements = Array.from(document.querySelectorAll(selectorValue2));
                }
                return elements;
              } catch (error) {
              }
            }, { selectorValue, isXPath });
            if (boxes && boxes.length >= 1) {
              processedOptions[ignoreOrSelectBoxes][viewportString].push(...boxes);
            } else {
              optionWarnings.add(`for snapshot ${snapshot.name} viewport ${viewportString}, no element found for selector ${selector}`);
            }
          }
        }
      }
      processedOptions.ignoreDOM = options == null ? void 0 : options.ignoreDOM;
      processedOptions.selectDOM = options == null ? void 0 : options.selectDOM;
      ctx.log.debug(`Processed options: ${JSON.stringify(processedOptions)}`);
    }
    const checkPending = () => __async(this, null, function* () {
      let startTime = Date.now();
      ctx.log.debug(`${pendingRequests.size} Pending requests before wait for ${snapshot.name}: ${Array.from(pendingRequests)}`);
      while (pendingRequests.size > 0) {
        const elapsedTime = Date.now() - startTime;
        if (elapsedTime >= MAX_WAIT_FOR_REQUEST_CALL) {
          ctx.log.debug(`Timeout reached (${MAX_WAIT_FOR_REQUEST_CALL / 1e3}s). Stopping wait for pending requests.`);
          ctx.log.debug(`${pendingRequests.size} Pending requests after wait for ${snapshot.name}: ${Array.from(pendingRequests)}`);
          break;
        }
        yield new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      if (pendingRequests.size === 0) {
        ctx.log.debug(`No pending requests for ${snapshot.name}.`);
      }
    });
    if (ctx.build.checkPendingRequests) {
      yield checkPending();
    }
    if (processedOptions.customCSS) {
      try {
        const cssRules = parseCSSFile(processedOptions.customCSS);
        const validationResult = yield validateCSSSelectors(page, cssRules, ctx.log);
        const report = generateCSSInjectionReport(validationResult, ctx.log);
        if (validationResult.failedSelectors.length > 0) {
          validationResult.failedSelectors.forEach((selector) => {
            optionWarnings.add(`customCSS selector not found: ${selector}`);
          });
        }
      } catch (error) {
        ctx.log.warn(`CSS validation failed: ${error.message}`);
        optionWarnings.add(`CSS validation error: ${error.message}`);
      }
    }
    let hasBrowserErrors = false;
    for (let browser in discoveryErrors.browsers) {
      if (discoveryErrors.browsers[browser]) {
        for (let viewport in discoveryErrors.browsers[browser]) {
          if (discoveryErrors.browsers[browser][viewport].length > 0) {
            hasBrowserErrors = true;
            ctx.build.hasDiscoveryError = true;
            break;
          }
        }
      }
    }
    if (hasBrowserErrors) {
      discoveryErrors.timestamp = (/* @__PURE__ */ new Date()).toISOString();
    }
    if (ctx.config.useGlobalCache) {
      const keys = globalCache.keys();
      keys.forEach((key) => {
        if (!(key in cache)) {
          const globalCacheData = globalCache.get(key);
          if (globalCacheData) {
            cache[key] = globalCacheData;
          }
        }
      });
    }
    return {
      processedSnapshot: {
        name: snapshot.name,
        url: snapshot.url,
        dom: Buffer.from(snapshot.dom.html).toString("base64"),
        resources: cache,
        options: processedOptions
      },
      warnings: [...optionWarnings, ...snapshot.dom.warnings],
      discoveryErrors
    };
  });
}
var uploadDomToS3ViaEnv3 = process.env.USE_LAMBDA_INTERNAL || false;
var Queue = class {
  constructor(ctx) {
    this.snapshots = [];
    this.processedSnapshots = [];
    this.processing = false;
    this.processingSnapshot = "";
    this.snapshotNames = [];
    this.variants = [];
    this.activeProcessingCount = 0;
    this.MAX_CONCURRENT_PROCESSING = 5;
    this.ctx = ctx;
  }
  enqueue(item) {
    this.snapshots.push(item);
    if (!this.ctx.config.delayedUpload) {
      if (!this.processing) {
        this.processing = true;
        this.processNext();
      }
    }
  }
  enqueueFront(item) {
    this.snapshots.unshift(item);
    if (!this.ctx.config.delayedUpload) {
      if (!this.processing) {
        this.processing = true;
        this.processNext();
      }
    }
  }
  startProcessingfunc() {
    if (!this.processing) {
      this.processing = true;
      this.processNext();
    }
  }
  processGenerateVariants(snapshot) {
    if (snapshot.options) {
      if (snapshot.options.web) {
        this.generateWebVariants(snapshot, snapshot.options.web);
      }
      if (snapshot.options.mobile) {
        this.generateMobileVariants(snapshot, snapshot.options.mobile);
      }
    }
    if (!snapshot.options || snapshot.options && !snapshot.options.web && !snapshot.options.mobile) {
      this.generateVariants(snapshot, this.ctx.config);
    }
  }
  generateVariants(snapshot, config) {
    if (config.web) {
      const browsers = config.web.browsers || [];
      const viewports = config.web.viewports || [];
      for (const browser of browsers) {
        for (const viewport of viewports) {
          const width = viewport.width;
          const height = viewport.height || 0;
          const variant = `${snapshot.name}_${browser}_viewport[${width}]_viewport[${height}]`;
          this.variants.push(variant);
        }
      }
    }
    if (config.mobile) {
      const devices = config.mobile.devices || [];
      const orientation = config.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT;
      for (const device of devices) {
        const variant = `${snapshot.name}_${device}_${orientation}`;
        this.variants.push(variant);
      }
    }
  }
  generateWebVariants(snapshot, webConfig) {
    var _a, _b, _c;
    const browsers = (_c = (_b = webConfig.browsers) != null ? _b : (_a = this.ctx.config.web) == null ? void 0 : _a.browsers) != null ? _c : [constants_default.CHROME, constants_default.EDGE, constants_default.FIREFOX, constants_default.SAFARI];
    const viewports = webConfig.viewports || [];
    for (const browser of browsers) {
      for (const viewport of viewports) {
        const width = viewport[0];
        const height = viewport[1] || 0;
        const variant = `${snapshot.name}_${browser}_viewport[${width}]_viewport[${height}]`;
        this.variants.push(variant);
      }
    }
  }
  generateMobileVariants(snapshot, mobileConfig) {
    var _a, _b, _c;
    const devices = mobileConfig.devices || [];
    const orientation = (_c = (_b = mobileConfig.orientation) != null ? _b : (_a = this.ctx.config.mobile) == null ? void 0 : _a.orientation) != null ? _c : constants_default.MOBILE_ORIENTATION_PORTRAIT;
    for (const device of devices) {
      const variant = `${snapshot.name}_${device}_${orientation}`;
      this.variants.push(variant);
    }
  }
  filterExistingVariants(snapshot, config) {
    let drop = true;
    if (snapshot.options && snapshot.options.web) {
      const webDrop = this.filterWebVariants(snapshot, snapshot.options.web);
      if (!webDrop)
        drop = false;
    }
    if (snapshot.options && snapshot.options.mobile) {
      const mobileDrop = this.filterMobileVariants(snapshot, snapshot.options.mobile);
      if (!mobileDrop)
        drop = false;
    }
    if (!snapshot.options || snapshot.options && !snapshot.options.web && !snapshot.options.mobile) {
      const configDrop = this.filterVariants(snapshot, config);
      if (!configDrop)
        drop = false;
    }
    return drop;
  }
  filterVariants(snapshot, config) {
    var _a;
    let allVariantsDropped = true;
    if (config.web) {
      const browsers = config.web.browsers || [];
      const viewports = config.web.viewports || [];
      for (const browser of browsers) {
        for (const viewport of viewports) {
          const width = viewport.width;
          const height = viewport.height || 0;
          const variant = `${snapshot.name}_${browser}_viewport[${width}]_viewport[${height}]`;
          if (!this.variants.includes(variant)) {
            allVariantsDropped = false;
            if (!snapshot.options)
              snapshot.options = {};
            if (!snapshot.options.web)
              snapshot.options.web = { browsers: [], viewports: [] };
            if (!snapshot.options.web.browsers.includes(browser)) {
              snapshot.options.web.browsers.push(browser);
            }
            const viewportExists = snapshot.options.web.viewports.some(
              (existingViewport) => existingViewport[0] === width && (existingViewport.length < 2 || existingViewport[1] === height)
            );
            if (!viewportExists) {
              if (height > 0) {
                snapshot.options.web.viewports.push([width, height]);
              } else {
                snapshot.options.web.viewports.push([width]);
              }
            }
          }
        }
      }
    }
    if (config.mobile) {
      const devices = config.mobile.devices || [];
      const orientation = config.mobile.orientation || constants_default.MOBILE_ORIENTATION_PORTRAIT;
      const fullPage = (_a = config.mobile.fullPage) != null ? _a : true;
      for (const device of devices) {
        const variant = `${snapshot.name}_${device}_${orientation}`;
        if (!this.variants.includes(variant)) {
          allVariantsDropped = false;
          if (!snapshot.options)
            snapshot.options = {};
          if (!snapshot.options.mobile)
            snapshot.options.mobile = { devices: [], orientation: constants_default.MOBILE_ORIENTATION_PORTRAIT, fullPage };
          if (!snapshot.options.mobile.devices.includes(device)) {
            snapshot.options.mobile.devices.push(device);
          }
          snapshot.options.mobile.orientation = orientation;
        }
      }
    }
    return allVariantsDropped;
  }
  filterWebVariants(snapshot, webConfig) {
    var _a, _b, _c;
    const browsers = (_c = (_b = webConfig.browsers) != null ? _b : (_a = this.ctx.config.web) == null ? void 0 : _a.browsers) != null ? _c : [constants_default.CHROME, constants_default.EDGE, constants_default.FIREFOX, constants_default.SAFARI];
    const viewports = webConfig.viewports || [];
    let allVariantsDropped = true;
    if (!snapshot.options) {
      snapshot.options = {};
    }
    snapshot.options.web = { browsers: [], viewports: [] };
    for (const browser of browsers) {
      for (const viewport of viewports) {
        const width = viewport[0];
        const height = viewport[1] || 0;
        const variant = `${snapshot.name}_${browser}_viewport[${width}]_viewport[${height}]`;
        if (!this.variants.includes(variant)) {
          allVariantsDropped = false;
          if (!snapshot.options.web.browsers.includes(browser)) {
            snapshot.options.web.browsers.push(browser);
          }
          const viewportExists = snapshot.options.web.viewports.some(
            (existingViewport) => existingViewport[0] === width && (existingViewport.length < 2 || existingViewport[1] === height)
          );
          if (!viewportExists) {
            if (height > 0) {
              snapshot.options.web.viewports.push([width, height]);
            } else {
              snapshot.options.web.viewports.push([width]);
            }
          }
        }
      }
    }
    return allVariantsDropped;
  }
  filterMobileVariants(snapshot, mobileConfig) {
    var _a, _b, _c, _d, _e, _f;
    if (!snapshot.options) {
      snapshot.options = {};
    }
    const devices = mobileConfig.devices || [];
    const orientation = (_c = (_b = mobileConfig.orientation) != null ? _b : (_a = this.ctx.config.mobile) == null ? void 0 : _a.orientation) != null ? _c : constants_default.MOBILE_ORIENTATION_PORTRAIT;
    const fullPage = (_f = (_e = mobileConfig.fullPage) != null ? _e : (_d = this.ctx.config.mobile) == null ? void 0 : _d.fullPage) != null ? _f : true;
    let allVariantsDropped = true;
    snapshot.options.mobile = { devices: [], orientation: constants_default.MOBILE_ORIENTATION_PORTRAIT, fullPage };
    for (const device of devices) {
      const variant = `${snapshot.name}_${device}_${orientation}`;
      if (!this.variants.includes(variant)) {
        allVariantsDropped = false;
        snapshot.options.mobile.devices.push(device);
        snapshot.options.mobile.orientation = orientation;
      }
    }
    return allVariantsDropped;
  }
  processNext() {
    return __async(this, null, function* () {
      if (!this.isEmpty()) {
        const useRemoteDiscovery = this.ctx.env.USE_REMOTE_DISCOVERY || this.ctx.config.useRemoteDiscovery;
        if (useRemoteDiscovery && !this.ctx.config.delayedUpload && !this.ctx.config.allowDuplicateSnapshotNames) {
          let maxConcurrentProcessing = this.ctx.env.MAX_CONCURRENT_PROCESSING === 0 ? this.MAX_CONCURRENT_PROCESSING : this.ctx.env.MAX_CONCURRENT_PROCESSING;
          if (maxConcurrentProcessing > 15 || maxConcurrentProcessing < 1) {
            this.ctx.log.info(`Larger than 15 concurrent processing. Setting to 5.`);
            maxConcurrentProcessing = 5;
          }
          this.ctx.log.info(`Max concurrent processing: ${maxConcurrentProcessing}`);
          const snapshotsToProcess = [];
          const maxSnapshots = Math.min(maxConcurrentProcessing - this.activeProcessingCount, this.snapshots.length);
          for (let i = 0; i < maxSnapshots; i++) {
            let snapshot2;
            if (this.ctx.config.delayedUpload) {
              snapshot2 = this.snapshots.pop();
            } else {
              snapshot2 = this.snapshots.shift();
            }
            if (snapshot2) {
              snapshotsToProcess.push(snapshot2);
            }
          }
          if (snapshotsToProcess.length > 0) {
            this.activeProcessingCount += snapshotsToProcess.length;
            const processingPromises = snapshotsToProcess.map((snapshot2) => this.processSnapshot(snapshot2));
            yield Promise.allSettled(processingPromises);
            this.activeProcessingCount -= snapshotsToProcess.length;
            if (!this.isEmpty()) {
              this.processNext();
            } else {
              this.processing = false;
            }
            return;
          }
        }
        let snapshot;
        if (this.ctx.config.delayedUpload) {
          snapshot = this.snapshots.pop();
        } else {
          snapshot = this.snapshots.shift();
        }
        if (snapshot) {
          yield this.processSnapshot(snapshot);
          this.processNext();
        }
      } else {
        this.processing = false;
      }
    });
  }
  processSnapshot(snapshot) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
      try {
        this.processingSnapshot = snapshot == null ? void 0 : snapshot.name;
        let drop = false;
        if (this.ctx.isStartExec) {
          this.ctx.log.info(`Processing Snapshot: ${snapshot == null ? void 0 : snapshot.name}`);
        }
        if (!this.ctx.config.delayedUpload && snapshot && snapshot.name && this.snapshotNames.includes(snapshot.name) && !this.ctx.config.allowDuplicateSnapshotNames) {
          if (this.ctx.sessionIdToSnapshotNameMap && snapshot.options && snapshot.options.sessionId) {
            if (this.ctx.sessionIdToSnapshotNameMap.has(snapshot.options.sessionId)) {
              console.log(`snapshot.options.sessionId`, snapshot.options.sessionId, `this.ctx.sessionIdToSnapshotNameMap`, JSON.stringify([...this.ctx.sessionIdToSnapshotNameMap]));
              const existingNames = this.ctx.sessionIdToSnapshotNameMap.get(snapshot.options.sessionId) || [];
              if (existingNames.includes(snapshot.name)) {
                drop = true;
                this.ctx.log.info(`Skipping123 duplicate SmartUI snapshot '${snapshot.name}'. To capture duplicate screenshots, please set the 'allowDuplicateSnapshotNames' or 'delayedUpload' configuration as true in your config file.`);
              } else {
                existingNames.push(snapshot.name);
                this.ctx.sessionIdToSnapshotNameMap.set(snapshot.options.sessionId, existingNames);
              }
            } else {
              this.ctx.sessionIdToSnapshotNameMap.set(snapshot.options.sessionId, [snapshot.name]);
            }
          } else {
            drop = true;
            this.ctx.log.info(`Skipping duplicate SmartUI snapshot '${snapshot.name}'. To capture duplicate screenshots, please set the 'allowDuplicateSnapshotNames' or 'delayedUpload' configuration as true in your config file.`);
          }
        }
        if (this.ctx.config.delayedUpload && snapshot && snapshot.name && this.snapshotNames.includes(snapshot.name)) {
          drop = this.filterExistingVariants(snapshot, this.ctx.config);
        }
        if (snapshot && snapshot.name && !this.snapshotNames.includes(snapshot.name) && !drop) {
          this.snapshotNames.push(snapshot.name);
        }
        if (this.ctx.config.delayedUpload && snapshot && !drop) {
          this.processGenerateVariants(snapshot);
        }
        if (!drop) {
          const sessionId = (_a = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _a.sessionId;
          let capsBuildId = "";
          let capsProjectToken = "";
          let useCapsBuildId = false;
          let useKafkaFlowCaps = false;
          if (sessionId && ((_b = this.ctx.sessionCapabilitiesMap) == null ? void 0 : _b.has(sessionId))) {
            const cachedCapabilities = this.ctx.sessionCapabilitiesMap.get(sessionId);
            capsProjectToken = (cachedCapabilities == null ? void 0 : cachedCapabilities.projectToken) || "";
            capsBuildId = (cachedCapabilities == null ? void 0 : cachedCapabilities.buildId) || "";
            useKafkaFlowCaps = (cachedCapabilities == null ? void 0 : cachedCapabilities.useKafkaFlow) || false;
            if (capsBuildId != "" && capsProjectToken != "") {
              useCapsBuildId = true;
            }
          }
          let processedSnapshot, warnings, discoveryErrors;
          if (this.ctx.env.USE_REMOTE_DISCOVERY || this.ctx.config.useRemoteDiscovery) {
            this.ctx.log.debug(`Using remote discovery`);
            let result = yield prepareSnapshot(snapshot, this.ctx);
            processedSnapshot = result.processedSnapshot;
            warnings = result.warnings;
          } else {
            this.ctx.log.debug(`Using local discovery`);
            let result = yield processSnapshot(snapshot, this.ctx);
            processedSnapshot = result.processedSnapshot;
            warnings = result.warnings;
            discoveryErrors = result.discoveryErrors;
          }
          if (useCapsBuildId) {
            this.ctx.log.info(`Using cached buildId: ${capsBuildId}`);
            let approvalThreshold = ((_c = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _c.approvalThreshold) || this.ctx.config.approvalThreshold;
            let rejectionThreshold = ((_d = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _d.rejectionThreshold) || this.ctx.config.rejectionThreshold;
            if (useKafkaFlowCaps) {
              let snapshotUuid = uuid.v4();
              if (((_e = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _e.contextId) && ((_f = this.ctx.contextToSnapshotMap) == null ? void 0 : _f.has(snapshot.options.contextId))) {
                snapshotUuid = snapshot.options.contextId;
              }
              let uploadDomToS3 = this.ctx.config.useLambdaInternal || uploadDomToS3ViaEnv3;
              if (!uploadDomToS3) {
                this.ctx.log.debug(`Uploading dom to S3 for snapshot using presigned URL for CAPS`);
                const presignedResponse = yield this.ctx.client.getS3PresignedURLForSnapshotUploadCaps(this.ctx, processedSnapshot.name, snapshotUuid, capsBuildId, capsProjectToken);
                const uploadUrl = presignedResponse.data.url;
                yield this.ctx.client.uploadSnapshotToS3Caps(this.ctx, uploadUrl, processedSnapshot, capsProjectToken);
              } else {
                this.ctx.log.debug(`Uploading dom to S3 for snapshot using LSRS`);
                yield this.ctx.client.sendDomToLSRSForCaps(this.ctx, processedSnapshot, snapshotUuid, capsBuildId, capsProjectToken);
              }
              yield this.ctx.client.processSnapshotCaps(this.ctx, processedSnapshot, snapshotUuid, capsBuildId, capsProjectToken, discoveryErrors, calculateVariantCountFromSnapshot(processedSnapshot, this.ctx.config), (_g = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _g.sync, approvalThreshold, rejectionThreshold);
            } else {
              yield this.ctx.client.uploadSnapshotForCaps(this.ctx, processedSnapshot, capsBuildId, capsProjectToken, discoveryErrors, calculateVariantCountFromSnapshot(processedSnapshot, this.ctx.config), (_h = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _h.sync, approvalThreshold, rejectionThreshold);
            }
            const cachedCapabilities = this.ctx.sessionCapabilitiesMap.get(sessionId);
            const currentCount = (cachedCapabilities == null ? void 0 : cachedCapabilities.snapshotCount) || 0;
            cachedCapabilities.snapshotCount = currentCount + 1;
            this.ctx.sessionCapabilitiesMap.set(sessionId, cachedCapabilities);
            if (((_i = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _i.contextId) && this.ctx.contextToSnapshotMap) {
              this.ctx.contextToSnapshotMap.set(snapshot.options.contextId, capsBuildId);
            }
          } else {
            if (!((_j = this.ctx.build) == null ? void 0 : _j.id)) {
              if (this.ctx.authenticatedInitially) {
                let resp = yield this.ctx.client.createBuild(this.ctx.git, this.ctx.config, this.ctx.log, this.ctx.build.name, false, false, false, "");
                this.ctx.build = {
                  id: resp.data.buildId,
                  name: resp.data.buildName,
                  url: resp.data.buildURL,
                  baseline: resp.data.baseline,
                  useKafkaFlow: resp.data.useKafkaFlow || false
                };
              } else {
                if (this.ctx.autoTunnelStarted) {
                  yield stopTunnelHelper(this.ctx);
                }
                throw new Error("SmartUI capabilities are missing in env variables or in driver capabilities");
              }
              if (this.ctx.options.fetchResults) {
                if (this.ctx.build && this.ctx.build.id) {
                  startPolling(this.ctx, "", false, "");
                }
              }
            }
            if (this.ctx.build && this.ctx.build.useKafkaFlow) {
              let snapshotUuid = uuid.v4();
              let snapshotUploadResponse;
              if (((_k = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _k.contextId) && ((_l = this.ctx.contextToSnapshotMap) == null ? void 0 : _l.has(snapshot.options.contextId))) {
                snapshotUuid = snapshot.options.contextId;
              }
              let uploadDomToS3 = this.ctx.config.useLambdaInternal || uploadDomToS3ViaEnv3;
              if (!uploadDomToS3) {
                this.ctx.log.debug(`Uploading dom to S3 for snapshot using presigned URL`);
                const presignedResponse = yield this.ctx.client.getS3PresignedURLForSnapshotUpload(this.ctx, processedSnapshot.name, snapshotUuid);
                const uploadUrl = presignedResponse.data.url;
                snapshotUploadResponse = yield this.ctx.client.uploadSnapshotToS3(this.ctx, uploadUrl, processedSnapshot);
              } else {
                this.ctx.log.debug(`Uploading dom to S3 for snapshot using LSRS`);
                snapshotUploadResponse = yield this.ctx.client.sendDomToLSRS(this.ctx, processedSnapshot, snapshotUuid);
              }
              if (!snapshotUploadResponse || Object.keys(snapshotUploadResponse).length === 0) {
                this.ctx.log.debug(`snapshot failed; Unable to upload dom to S3`);
                this.processedSnapshots.push({ name: snapshot == null ? void 0 : snapshot.name, error: `snapshot failed; Unable to upload dom to S3` });
                if (this.ctx.browser) {
                  for (let context of this.ctx.browser.contexts()) {
                    for (let page of context.pages()) {
                      yield page.close();
                      this.ctx.log.debug(`Closed browser page for snapshot ${snapshot.name}`);
                    }
                    yield context.close();
                    this.ctx.log.debug(`Closed browser context for snapshot ${snapshot.name}`);
                  }
                }
                if ((_m = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _m.contextId) {
                  (_o = this.ctx.contextToSnapshotMap) == null ? void 0 : _o.set((_n = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _n.contextId, "2");
                }
              } else {
                let approvalThreshold = ((_p = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _p.approvalThreshold) || this.ctx.config.approvalThreshold;
                let rejectionThreshold = ((_q = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _q.rejectionThreshold) || this.ctx.config.rejectionThreshold;
                yield this.ctx.client.processSnapshot(this.ctx, processedSnapshot, snapshotUuid, discoveryErrors, calculateVariantCountFromSnapshot(processedSnapshot, this.ctx.config), (_r = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _r.sync, approvalThreshold, rejectionThreshold);
                if (((_s = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _s.contextId) && ((_t = this.ctx.contextToSnapshotMap) == null ? void 0 : _t.has(snapshot.options.contextId))) {
                  this.ctx.contextToSnapshotMap.set(snapshot.options.contextId, this.ctx.build.id);
                }
                this.ctx.log.debug(`ContextId: ${(_u = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _u.contextId} status set to uploaded`);
              }
            } else {
              this.ctx.log.info(`Uploading snapshot to S3`);
              yield this.ctx.client.uploadSnapshot(this.ctx, processedSnapshot, discoveryErrors);
            }
            this.ctx.totalSnapshots++;
          }
          this.processedSnapshots.push({ name: snapshot == null ? void 0 : snapshot.name, warnings });
        }
      } catch (error) {
        this.ctx.log.debug(`snapshot failed; ${error}`);
        this.processedSnapshots.push({ name: snapshot == null ? void 0 : snapshot.name, error: error.message });
        if (((_v = snapshot == null ? void 0 : snapshot.options) == null ? void 0 : _v.contextId) && this.ctx.contextToSnapshotMap) {
          this.ctx.contextToSnapshotMap.set(snapshot.options.contextId, "2");
        }
      }
      if (this.ctx.browser) {
        for (let context of this.ctx.browser.contexts()) {
          for (let page of context.pages()) {
            yield page.close();
            this.ctx.log.debug(`Closed browser page for snapshot ${snapshot.name}`);
          }
          yield context.close();
          this.ctx.log.debug(`Closed browser context for snapshot ${snapshot.name}`);
        }
      }
    });
  }
  isProcessing() {
    return this.processing;
  }
  getProcessingSnapshot() {
    return this.processingSnapshot;
  }
  getProcessedSnapshots() {
    return this.processedSnapshots;
  }
  isEmpty() {
    return this.snapshots && this.snapshots.length ? false : true;
  }
};
var startTunnel_default = (ctx) => {
  return {
    title: `Starting Tunnel`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "startTunnel" });
      try {
        yield startTunnelBinary(ctx2);
        ctx2.isStartExec = true;
        ctx2.autoTunnelStarted = true;
        task.title = "Tunnel Started";
        task.output = chalk__default.default.gray("Tunnel started successfully");
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Error while starting tunnel binary");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// src/commander/exec.ts
var command = new commander.Command();
command.name("exec").description("Run test commands around SmartUI").argument("<command...>", "Command supplied for running tests").option("-P, --port <number>", "Port number for the server").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").option("--buildName <string>", "Specify the build name").option("--scheduled <string>", "Specify the schedule ID").option("--show-render-errors", "Show render errors from SmartUI build").action(function(execCommand, _, command11) {
  return __async(this, null, function* () {
    var _a;
    const options = command11.optsWithGlobals();
    if (options.buildName === "") {
      console.log(`Error: The '--buildName' option cannot be an empty string.`);
      process.exit(1);
    }
    let ctx = ctx_default(command11.optsWithGlobals());
    if (!which__default.default.sync(execCommand[0], { nothrow: true })) {
      ctx.log.error(`Error: Command not found "${execCommand[0]}"`);
      return;
    }
    ctx.args.execCommand = execCommand;
    ctx.snapshotQueue = new Queue(ctx);
    ctx.totalSnapshots = 0;
    ctx.sourceCommand = "exec";
    execCommandOptions_default(ctx);
    let tasks = new listr2.Listr(
      [
        authExec_default(),
        startServer_default(),
        getGitInfo_default(),
        ...ctx.config.tunnel && ((_a = ctx.config.tunnel) == null ? void 0 : _a.type) === "auto" ? [startTunnel_default()] : [],
        createBuildExec_default(),
        exec_default(ctx),
        processSnapshot_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      ctx.log.info("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
      process.exitCode = 1;
      throw new Error();
    }
  });
});
var exec_default2 = command;
function createConfig(filepath) {
  filepath = filepath || ".smartui.json";
  let filetype = path3__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: Config file must have .json extension");
    return;
  }
  if (fs6__default.default.existsSync(filepath)) {
    console.log(`Error: SmartUI Config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create .smartui-config.json'`);
    return;
  }
  fs6__default.default.mkdirSync(path3__default.default.dirname(filepath), { recursive: true });
  fs6__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_CONFIG, null, 2) + "\n");
  console.log(`Created SmartUI Config: ${filepath}`);
}
function createWebStaticConfig(filepath) {
  filepath = filepath || "url.json";
  let filetype = path3__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: Config file must have .json extension");
    return;
  }
  if (fs6__default.default.existsSync(filepath)) {
    console.log(`Error: web-static config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create-web-static links.json'`);
    return;
  }
  fs6__default.default.mkdirSync(path3__default.default.dirname(filepath), { recursive: true });
  fs6__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_WEB_STATIC_CONFIG, null, 2) + "\n");
  console.log(`Created web-static config: ${filepath}`);
}
function createFigmaConfig(filepath) {
  filepath = filepath || "designs.json";
  let filetype = path3__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: designs config file must have .json extension");
    return;
  }
  if (fs6__default.default.existsSync(filepath)) {
    console.log(`Error: designs config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:figma-config designs.json'`);
    return;
  }
  fs6__default.default.mkdirSync(path3__default.default.dirname(filepath), { recursive: true });
  fs6__default.default.writeFileSync(filepath, JSON.stringify(constants_default.DEFAULT_FIGMA_CONFIG, null, 2) + "\n");
  console.log(`Created designs config: ${filepath}`);
}
function createWebFigmaConfig(filepath) {
  filepath = filepath || ".smartui.json";
  let filetype = path3__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: figma config file must have .json extension");
    return;
  }
  if (fs6__default.default.existsSync(filepath)) {
    console.log(`Error: figma config already exists: ${filepath}`);
    console.log(`To create a new file, please specify the file name like: 'smartui config:create-figma-web <fileName>.json'`);
    return;
  }
  fs6__default.default.mkdirSync(path3__default.default.dirname(filepath), { recursive: true });
  fs6__default.default.writeFileSync(filepath, JSON.stringify(constants_default.WEB_FIGMA_CONFIG, null, 2) + "\n");
  console.log(`Created figma web config: ${filepath}`);
}
function verifyFigmaWebConfig(ctx) {
  var _a, _b;
  if (ctx.env.FIGMA_TOKEN == "") {
    throw new Error("Missing FIGMA_TOKEN in Environment Variables");
  }
  if (ctx.env.LT_USERNAME == "") {
    throw new Error("Missing LT_USERNAME in Environment Variables");
  }
  if (ctx.env.LT_ACCESS_KEY == "") {
    throw new Error("Missing LT_ACCESS_KEY in Environment Variables");
  }
  let figma = ctx.config && ((_a = ctx.config) == null ? void 0 : _a.figma) || {};
  const screenshots = [];
  for (let c of figma == null ? void 0 : figma.configs) {
    if (c.screenshot_names && c.screenshot_names.length > 0 && c.figma_ids && c.figma_ids.length != c.screenshot_names.length) {
      throw new Error("Mismatch in Figma Ids and Screenshot Names in figma config");
    }
    if (isValidArray(c.screenshot_names)) {
      for (const name of c.screenshot_names) {
        screenshots.push(name);
      }
    }
  }
  if (new Set(screenshots).size !== screenshots.length) {
    throw new Error("Found duplicate screenshot names in figma config");
  }
  let mobileConfig = ((_b = ctx.config) == null ? void 0 : _b.mobile) || {};
  if (Array.isArray(mobileConfig)) {
    for (const config of mobileConfig) {
      const deviceName = config.name;
      if (constants_default.SUPPORTED_MOBILE_DEVICES[deviceName]) {
        const deviceData = constants_default.SUPPORTED_MOBILE_DEVICES[deviceName];
        config.width = deviceData.viewport.width;
        config.height = deviceData.viewport.height;
      }
    }
  }
}
function isValidArray(input) {
  return Array.isArray(input) && input.length > 0;
}
function createAppFigmaConfig(filepath) {
  filepath = filepath || ".smartui.json";
  let filetype = path3__default.default.extname(filepath);
  if (filetype != ".json") {
    console.log("Error: figma app config file must have .json extension");
    return;
  }
  if (fs6__default.default.existsSync(filepath)) {
    console.log(`Error: figma app config already exists: ${filepath}`);
    console.log(`To create a new figma app config, please specify the file name like: 'smartui config:create-figma-app <fileName>.json'`);
    return;
  }
  fs6__default.default.mkdirSync(path3__default.default.dirname(filepath), { recursive: true });
  fs6__default.default.writeFileSync(filepath, JSON.stringify(constants_default.APP_FIGMA_CONFIG, null, 2) + "\n");
  console.log(`Created figma app config: ${filepath}`);
}

// src/commander/config.ts
var configWeb = new commander.Command();
var configStatic = new commander.Command();
var configFigma = new commander.Command();
var configWebFigma = new commander.Command();
var configAppFigma = new commander.Command();
configWeb.name("config:create").description("Create SmartUI config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createConfig(filepath);
  });
});
configStatic.name("config:create-web-static").description("Create Web Static config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createWebStaticConfig(filepath);
  });
});
configFigma.name("config:create-figma").description("Create figma designs config file").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createFigmaConfig(filepath);
  });
});
configWebFigma.name("config:create-figma-web").description("Create figma config file with browsers").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createWebFigmaConfig(filepath);
  });
});
configAppFigma.name("config:create-figma-app").description("Create figma config file for mobile apps").argument("[filepath]", "Optional config filepath").action(function(filepath, options) {
  return __async(this, null, function* () {
    createAppFigmaConfig(filepath);
  });
});
var auth_default = (ctx) => {
  return {
    title: `Authenticating with SmartUI`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "auth" });
      try {
        const { authResult, orgId, userId } = yield ctx2.client.auth(ctx2.log, ctx2.env);
        if (authResult === 2) {
          task.output = chalk__default.default.gray(`New project '${ctx2.env.PROJECT_NAME}' created successfully`);
        } else if (authResult === 0) {
          task.output = chalk__default.default.gray(`Using existing project token '******#${ctx2.env.PROJECT_TOKEN.split("#").pop()}'`);
        } else if (authResult === 1) {
          task.output = chalk__default.default.gray(`Using existing project '${ctx2.env.PROJECT_NAME}'`);
        }
        ctx2.orgId = orgId;
        ctx2.userId = userId;
        task.title = "Authenticated with SmartUI";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Authentication failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var createBuild_default = (ctx) => {
  return {
    title: `Creating SmartUI build`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "createBuild" });
      try {
        let resp = yield ctx2.client.createBuild(ctx2.git, ctx2.config, ctx2.log, ctx2.build.name, ctx2.isStartExec, ctx2.env.SMART_GIT, ctx2.options.markBaseline, ctx2.options.baselineBuild, ctx2.options.scheduled, ctx2.env.LT_USERNAME, ctx2.env.LT_ACCESS_KEY);
        if (resp && resp.data && resp.data.buildId) {
          ctx2.build = {
            id: resp.data.buildId,
            name: resp.data.buildName,
            url: resp.data.buildURL,
            baseline: resp.data.baseline,
            useKafkaFlow: resp.data.useKafkaFlow || false,
            checkPendingRequests: resp.data.checkPendingRequests || false
          };
          process.env.SMARTUI_BUILD_ID = resp.data.buildId;
          process.env.SMARTUI_BUILD_NAME = resp.data.buildName;
        } else if (resp && resp.error) {
          if (resp.error.message) {
            ctx2.log.error(`Error while creation of build: ${resp.error.message}`);
            throw new Error(`Error while creation of build: ${resp.error.message}`);
          }
        }
        task.output = chalk__default.default.gray(`build id: ${resp.data.buildId}`);
        task.title = "SmartUI build created";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("SmartUI build creation failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
function captureScreenshotsForConfig(ctx, browsers, urlConfig, browserName, renderViewports) {
  return __async(this, null, function* () {
    ctx.log.debug(`*** urlConfig  ${JSON.stringify(urlConfig)}`);
    let { name, url, waitForTimeout, execute, pageEvent, userAgent } = urlConfig;
    let beforeNavigationScript = execute == null ? void 0 : execute.beforeNavigation;
    let afterNavigationScript = execute == null ? void 0 : execute.afterNavigation;
    let beforeSnapshotScript = execute == null ? void 0 : execute.beforeSnapshot;
    let waitUntilEvent = pageEvent || process.env.SMARTUI_PAGE_WAIT_UNTIL_EVENT || "load";
    let discoveryErrors = {
      name: "",
      url: "",
      timestamp: "",
      snapshotUUID: "",
      browsers: {}
    };
    let globalViewport = "";
    let globalBrowser = constants_default.CHROME;
    let pageOptions = { waitUntil: waitUntilEvent, timeout: ctx.config.waitForPageRender || constants_default.DEFAULT_PAGE_LOAD_TIMEOUT };
    ctx.log.debug(`url:  ${url}  pageOptions: ${JSON.stringify(pageOptions)}`);
    let ssId = name.toLowerCase().replace(/\s/g, "_");
    let context;
    let contextOptions = {
      ignoreHTTPSErrors: ctx.config.ignoreHTTPSErrors
    };
    try {
      if (ctx.config.tunnel && ctx.config.tunnel.tunnelName) {
        if (ctx.tunnelDetails && ctx.tunnelDetails.tunnelPort != -1 && ctx.tunnelDetails.tunnelHost) {
          const tunnelServer = `http://${ctx.tunnelDetails.tunnelHost}:${ctx.tunnelDetails.tunnelPort}`;
          ctx.log.info(`URL Capture :: Using tunnel address: ${tunnelServer}`);
          contextOptions.proxy = { server: tunnelServer };
        } else {
          let tunnelResp = yield ctx.client.getTunnelDetails(ctx, ctx.log);
          ctx.log.debug(`Tunnel Response: ${JSON.stringify(tunnelResp)}`);
          if (tunnelResp && tunnelResp.data && tunnelResp.data.host && tunnelResp.data.port) {
            ctx.tunnelDetails = {
              tunnelHost: tunnelResp.data.host,
              tunnelPort: tunnelResp.data.port,
              tunnelName: tunnelResp.data.tunnel_name
            };
            const tunnelServer = `http://${ctx.tunnelDetails.tunnelHost}:${ctx.tunnelDetails.tunnelPort}`;
            ctx.log.info(`URL Capture :: Using tunnel address: ${tunnelServer}`);
            contextOptions.proxy = { server: tunnelServer };
          } else if (tunnelResp && tunnelResp.error) {
            if (tunnelResp.error.message) {
              ctx.log.warn(`Error while fetching tunnel details: ${tunnelResp.error.message}`);
            }
          }
        }
      } else if (ctx.config.geolocation && ctx.config.geolocation !== "") {
        if (ctx.geolocationData && ctx.geolocationData.proxy && ctx.geolocationData.username && ctx.geolocationData.password && ctx.geolocationData.geoCode === ctx.config.geolocation) {
          ctx.log.info(`URL Capture :: Using cached geolocation proxy for ${ctx.config.geolocation}`);
          contextOptions.proxy = {
            server: ctx.geolocationData.proxy,
            username: ctx.geolocationData.username,
            password: ctx.geolocationData.password
          };
        } else {
          const geoResp = yield ctx.client.getGeolocationProxy(ctx.config.geolocation, ctx.log);
          ctx.log.debug(`Geolocation proxy response: ${JSON.stringify(geoResp)}`);
          if (geoResp && geoResp.data && geoResp.data.proxy && geoResp.data.username && geoResp.data.password) {
            ctx.log.info(`URL Capture :: Using geolocation proxy for ${ctx.config.geolocation}`);
            ctx.geolocationData = {
              proxy: geoResp.data.proxy,
              username: geoResp.data.username,
              password: geoResp.data.password,
              geoCode: ctx.config.geolocation
            };
            contextOptions.proxy = {
              server: geoResp.data.proxy,
              username: geoResp.data.username,
              password: geoResp.data.password
            };
          } else {
            ctx.log.warn(`Geolocation proxy not available for '${ctx.config.geolocation}', falling back if dedicatedProxyURL present`);
            if (ctx.config.dedicatedProxyURL && ctx.config.dedicatedProxyURL !== "") {
              ctx.log.info(`URL Capture :: Using dedicated proxy: ${ctx.config.dedicatedProxyURL}`);
              contextOptions.proxy = { server: ctx.config.dedicatedProxyURL };
            }
          }
        }
      } else if (ctx.config.dedicatedProxyURL && ctx.config.dedicatedProxyURL !== "") {
        ctx.log.info(`URL Capture :: Using dedicated proxy: ${ctx.config.dedicatedProxyURL}`);
        contextOptions.proxy = { server: ctx.config.dedicatedProxyURL };
      }
    } catch (e) {
      ctx.log.debug(`Failed resolving tunnel/proxy details: ${e}`);
    }
    let page;
    if (browserName == constants_default.CHROME)
      contextOptions.userAgent = constants_default.CHROME_USER_AGENT;
    else if (browserName == constants_default.FIREFOX)
      contextOptions.userAgent = constants_default.FIREFOX_USER_AGENT;
    else if (browserName == constants_default.SAFARI)
      contextOptions.userAgent = constants_default.SAFARI_USER_AGENT;
    else if (browserName == constants_default.EDGE)
      contextOptions.userAgent = constants_default.EDGE_USER_AGENT;
    if (ctx.config.userAgent || userAgent) {
      if (ctx.config.userAgent !== "") {
        contextOptions.userAgent = ctx.config.userAgent;
      }
      if (userAgent && userAgent !== "") {
        contextOptions.userAgent = userAgent;
      }
    }
    try {
      const browser = browsers[browserName];
      context = yield browser == null ? void 0 : browser.newContext(contextOptions);
      page = yield context == null ? void 0 : context.newPage();
      if (beforeNavigationScript && beforeNavigationScript !== "") {
        const wrappedScript = new Function("page", `
                return (async () => {
                    ${beforeNavigationScript}
                })();
            `);
        ctx.log.debug(`Executing before navigation script: ${wrappedScript}`);
        yield wrappedScript(page);
      }
      const headersObject = {};
      if (ctx.config.requestHeaders && Array.isArray(ctx.config.requestHeaders)) {
        ctx.config.requestHeaders.forEach((headerObj) => {
          Object.entries(headerObj).forEach(([key, value]) => {
            headersObject[key] = value;
          });
        });
      }
      if (urlConfig.requestHeaders && Array.isArray(urlConfig.requestHeaders)) {
        urlConfig.requestHeaders.forEach((headerObj) => {
          Object.entries(headerObj).forEach(([key, value]) => {
            headersObject[key] = value;
          });
        });
      }
      if (ctx.config.basicAuthorization) {
        ctx.log.debug(`Adding basic authorization to the headers for root url`);
        let token = Buffer.from(`${ctx.config.basicAuthorization.username}:${ctx.config.basicAuthorization.password}`).toString("base64");
        headersObject["Authorization"] = `Basic ${token}`;
      }
      ctx.log.debug(`Combined headers: ${JSON.stringify(headersObject)}`);
      if (Object.keys(headersObject).length > 0) {
        yield page.setExtraHTTPHeaders(headersObject);
      }
      if (ctx.env.CAPTURE_RENDERING_ERRORS) {
        yield page.route("**/*", (route, request) => __async(this, null, function* () {
          var _a;
          const requestUrl = request.url();
          const requestHostname = new URL(requestUrl).hostname;
          let requestOptions = {
            timeout: 3e4,
            headers: __spreadValues(__spreadValues({}, yield request.allHeaders()), constants_default.REQUEST_HEADERS)
          };
          try {
            let response, body;
            response = yield page.request.fetch(request, requestOptions);
            body = yield response.body();
            let data = {
              statusCode: `${response.status()}`,
              url: requestUrl
            };
            if (response.status() >= 400 && response.status() < 600 && response.status() !== 0) {
              if (!discoveryErrors.browsers[globalBrowser]) {
                discoveryErrors.browsers[globalBrowser] = {};
              }
              if (discoveryErrors.browsers[globalBrowser] && !discoveryErrors.browsers[globalBrowser][globalViewport]) {
                discoveryErrors.browsers[globalBrowser][globalViewport] = [];
              }
              if (discoveryErrors.browsers[globalBrowser]) {
                (_a = discoveryErrors.browsers[globalBrowser][globalViewport]) == null ? void 0 : _a.push(data);
              }
              ctx.build.hasDiscoveryError = true;
            }
            route.fulfill({
              status: response.status(),
              headers: response.headers(),
              body
            });
          } catch (error) {
            ctx.log.debug(`Handling request ${requestUrl}
 - aborted due to ${error.message}`);
            route.abort();
          }
        }));
      }
      if (renderViewports && renderViewports.length > 0) {
        const first = renderViewports[0];
        globalViewport = first.viewportString;
        globalBrowser = browserName;
        if (globalViewport.toLowerCase().includes("iphone") || globalViewport.toLowerCase().includes("ipad")) {
          globalBrowser = constants_default.WEBKIT;
        }
      }
      if (browserName == constants_default.SAFARI || (globalViewport.toLowerCase().includes("iphone") || globalViewport.toLowerCase().includes("ipad"))) {
        globalBrowser = constants_default.WEBKIT;
      }
      yield page == null ? void 0 : page.goto(url.trim(), pageOptions);
      yield executeDocumentScripts(ctx, page, "afterNavigation", afterNavigationScript);
      for (let { viewport, viewportString, fullPage } of renderViewports) {
        globalViewport = viewportString;
        globalBrowser = browserName;
        ctx.log.debug(`globalViewport : ${globalViewport}`);
        if (browserName == constants_default.SAFARI || (globalViewport.toLowerCase().includes("iphone") || globalViewport.toLowerCase().includes("ipad"))) {
          globalBrowser = constants_default.WEBKIT;
        }
        let ssPath = `screenshots/${ssId}/${`${browserName}-${viewport.width}x${viewport.height}`}-${ssId}.png`;
        yield page == null ? void 0 : page.setViewportSize({ width: viewport.width, height: viewport.height || constants_default.MIN_VIEWPORT_HEIGHT });
        if (fullPage)
          yield page == null ? void 0 : page.evaluate(scrollToBottomAndBackToTop);
        yield page == null ? void 0 : page.waitForTimeout(waitForTimeout || 0);
        yield executeDocumentScripts(ctx, page, "beforeSnapshot", beforeSnapshotScript);
        discoveryErrors.name = name;
        discoveryErrors.url = url;
        discoveryErrors.timestamp = (/* @__PURE__ */ new Date()).toISOString();
        yield page == null ? void 0 : page.screenshot({ path: ssPath, fullPage });
        yield ctx.client.uploadScreenshot(ctx.build, ssPath, name, browserName, viewportString, url, ctx.log, discoveryErrors, ctx);
        discoveryErrors = {
          name: "",
          url: "",
          timestamp: "",
          snapshotUUID: "",
          browsers: {}
        };
      }
    } catch (error) {
      throw new Error(`captureScreenshotsForConfig failed for browser ${browserName}; error: ${error}`);
    } finally {
      yield page == null ? void 0 : page.close();
      yield context == null ? void 0 : context.close();
    }
  });
}
function captureScreenshotsAsync(ctx, staticConfig, browsers) {
  return __async(this, null, function* () {
    let capturePromises = [];
    if (ctx.config.web) {
      for (let browserName of ctx.config.web.browsers) {
        let webRenderViewports = getWebRenderViewports(ctx);
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, browserName, webRenderViewports));
      }
    }
    if (ctx.config.mobile) {
      let mobileRenderViewports = getMobileRenderViewports(ctx);
      if (mobileRenderViewports[constants_default.MOBILE_OS_IOS].length) {
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.SAFARI, mobileRenderViewports[constants_default.MOBILE_OS_IOS]));
      }
      if (mobileRenderViewports[constants_default.MOBILE_OS_ANDROID].length) {
        capturePromises.push(captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.CHROME, mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]));
      }
    }
    return Promise.all(capturePromises);
  });
}
function captureScreenshotsSync(ctx, staticConfig, browsers) {
  return __async(this, null, function* () {
    if (ctx.config.web) {
      for (let browserName of ctx.config.web.browsers) {
        let webRenderViewports = getWebRenderViewports(ctx);
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, browserName, webRenderViewports);
      }
    }
    if (ctx.config.mobile) {
      let mobileRenderViewports = getMobileRenderViewports(ctx);
      if (mobileRenderViewports[constants_default.MOBILE_OS_IOS].length) {
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.SAFARI, mobileRenderViewports[constants_default.MOBILE_OS_IOS]);
      }
      if (mobileRenderViewports[constants_default.MOBILE_OS_ANDROID].length) {
        yield captureScreenshotsForConfig(ctx, browsers, staticConfig, constants_default.CHROME, mobileRenderViewports[constants_default.MOBILE_OS_ANDROID]);
      }
    }
  });
}
function captureScreenshots(ctx) {
  return __async(this, null, function* () {
    delDir("screenshots");
    let browsers = {};
    let capturedScreenshots = 0;
    let output = "";
    try {
      browsers = yield launchBrowsers(ctx);
    } catch (error) {
      yield closeBrowsers(browsers);
      ctx.log.debug(error);
      throw new Error(`Failed launching browsers`);
    }
    for (let staticConfig of ctx.webStaticConfig) {
      try {
        if (ctx.options.parallel)
          yield captureScreenshotsAsync(ctx, staticConfig, browsers);
        else
          yield captureScreenshotsSync(ctx, staticConfig, browsers);
        delDir(`screenshots/${staticConfig.name.toLowerCase().replace(/\s/g, "_")}`);
        output += `${chalk__default.default.gray(staticConfig.name)} ${chalk__default.default.green("\u2713")}
`;
        ctx.task.output = output;
        capturedScreenshots++;
      } catch (error) {
        ctx.log.debug(`captureScreenshots failed for ${JSON.stringify(staticConfig)}; error: ${error}`);
        output += `${chalk__default.default.gray(staticConfig.name)} ${chalk__default.default.red("\u2717")}
`;
        ctx.task.output = output;
      }
    }
    yield closeBrowsers(browsers);
    delDir("screenshots");
    return { capturedScreenshots, output };
  });
}
function getImageDimensions(filePath) {
  const buffer = fs6__default.default.readFileSync(filePath);
  let width, height;
  if (buffer.toString("hex", 0, 2) === "ffd8") {
    let offset = 2;
    while (offset < buffer.length) {
      const marker = buffer.toString("hex", offset, offset + 2);
      offset += 2;
      const length = buffer.readUInt16BE(offset);
      if (marker === "ffc0" || marker === "ffc2") {
        height = buffer.readUInt16BE(offset + 3);
        width = buffer.readUInt16BE(offset + 5);
        return { width, height };
      }
      offset += length;
    }
  } else if (buffer.toString("hex", 1, 4) === "504e47") {
    width = buffer.readUInt32BE(16);
    height = buffer.readUInt32BE(20);
    return { width, height };
  }
  return null;
}
function isAllowedImage(filePath) {
  return __async(this, null, function* () {
    try {
      const fileBuffer = fs6__default.default.readFileSync(filePath);
      const isMagicValid = constants_default.MAGIC_NUMBERS.some((magic) => fileBuffer.slice(0, magic.magic.length).equals(magic.magic));
      const metadata = yield sharp__default.default(filePath).metadata();
      if (metadata.format === constants_default.FILE_EXTENSION_GIFS) {
        return false;
      }
      if (metadata.width > 0 && metadata.height > 0) {
        return true;
      }
      if (isMagicValid && metadata.format !== constants_default.FILE_EXTENSION_GIFS) {
        return true;
      }
      return false;
    } catch (error) {
      return false;
    }
  });
}
function uploadScreenshots(ctx) {
  return __async(this, null, function* () {
    const allowedExtensions = ctx.options.fileExtension.map((ext) => `.${ext.trim().toLowerCase()}`);
    let noOfScreenshots = 0;
    function processDirectory(directory, relativePath = "") {
      return __async(this, null, function* () {
        const files = fs6__default.default.readdirSync(directory);
        for (let file of files) {
          const filePath = path3__default.default.join(directory, file);
          const stat = fs6__default.default.statSync(filePath);
          const relativeFilePath = path3__default.default.join(relativePath, file);
          if (stat.isDirectory() && ctx.options.ignorePattern.includes(relativeFilePath)) {
            ctx.log.info(`Ignoring Directory ${relativeFilePath}`);
            continue;
          }
          if (stat.isDirectory()) {
            yield processDirectory(filePath, relativeFilePath);
          } else {
            let fileExtension = path3__default.default.extname(file).toLowerCase();
            if (allowedExtensions.includes(fileExtension)) {
              const isValid = yield isAllowedImage(filePath);
              if (!isValid) {
                ctx.log.info(`File ${filePath} is not a valid ${fileExtension} image or is corrupted. Skipping.`);
                continue;
              }
              let ssId = relativeFilePath;
              if (ctx.options.stripExtension) {
                ssId = path3__default.default.join(relativePath, path3__default.default.basename(file, fileExtension));
              }
              let viewport = "default";
              if (!ctx.options.ignoreResolutions) {
                const dimensions = getImageDimensions(filePath);
                if (!dimensions) {
                  ctx.log.info(`Unable to determine dimensions for image: ${filePath}`);
                } else {
                  const width = dimensions.width;
                  const height = dimensions.height;
                  viewport = `${width}x${height}`;
                }
              }
              yield ctx.client.uploadScreenshot(ctx.build, filePath, ssId, "default", viewport, "", ctx.log, {
                name: "",
                url: "",
                timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                snapshotUUID: "",
                browsers: {}
              }, ctx);
              ctx.log.info(`${filePath} : uploaded successfully`);
              noOfScreenshots++;
            } else {
              ctx.log.info(`File ${filePath} has invalid file extension: ${fileExtension}. Skipping`);
            }
          }
        }
      });
    }
    yield processDirectory(ctx.uploadFilePath);
    if (noOfScreenshots == 0) {
      ctx.log.info(`No screenshots uploaded.`);
    } else {
      ctx.log.info(`${noOfScreenshots} screenshots uploaded successfully.`);
    }
  });
}
function captureScreenshotsConcurrent(ctx) {
  return __async(this, null, function* () {
    delDir("screenshots");
    let totalSnapshots = ctx.webStaticConfig && ctx.webStaticConfig.length;
    let browserInstances = ctx.options.parallel || 1;
    let optimizeBrowserInstances = 0;
    optimizeBrowserInstances = Math.floor(Math.log2(totalSnapshots));
    if (optimizeBrowserInstances < 1) {
      optimizeBrowserInstances = 1;
    }
    if (optimizeBrowserInstances > browserInstances) {
      optimizeBrowserInstances = browserInstances;
    }
    if (ctx.options.force && browserInstances > 1) {
      optimizeBrowserInstances = browserInstances;
    }
    let urlsPerInstance = 0;
    if (optimizeBrowserInstances == 1) {
      urlsPerInstance = totalSnapshots;
    } else {
      urlsPerInstance = Math.ceil(totalSnapshots / optimizeBrowserInstances);
    }
    ctx.log.debug(`*** browserInstances requested ${ctx.options.parallel} `);
    ctx.log.debug(`*** optimizeBrowserInstances  ${optimizeBrowserInstances} `);
    ctx.log.debug(`*** urlsPerInstance  ${urlsPerInstance}`);
    ctx.task.output = `URLs : ${totalSnapshots} || Parallel Browser Instances: ${optimizeBrowserInstances}
`;
    let staticURLChunks = splitURLs(ctx.webStaticConfig, urlsPerInstance);
    let totalCapturedScreenshots = 0;
    let output = "";
    const responses = yield Promise.all(staticURLChunks.map((urlConfig) => __async(this, null, function* () {
      let { capturedScreenshots, finalOutput } = yield processChunk(ctx, urlConfig);
      return { capturedScreenshots, finalOutput };
    })));
    responses.forEach((response) => {
      totalCapturedScreenshots += response.capturedScreenshots;
      output += response.finalOutput;
    });
    delDir("screenshots");
    return { totalCapturedScreenshots, output };
  });
}
function splitURLs(arr, chunkSize) {
  const result = [];
  for (let i = 0; i < arr.length; i += chunkSize) {
    result.push(arr.slice(i, i + chunkSize));
  }
  return result;
}
function processChunk(ctx, urlConfig) {
  return __async(this, null, function* () {
    let browsers = {};
    let capturedScreenshots = 0;
    let finalOutput = "";
    try {
      browsers = yield launchBrowsers(ctx);
    } catch (error) {
      yield closeBrowsers(browsers);
      ctx.log.debug(error);
      throw new Error(`Failed launching browsers ${error}`);
    }
    for (let staticConfig of urlConfig) {
      try {
        yield captureScreenshotsAsync(ctx, staticConfig, browsers);
        delDir(`screenshots/${staticConfig.name.toLowerCase().replace(/\s/g, "_")}`);
        let output = `${chalk__default.default.gray(staticConfig.name)} ${chalk__default.default.green("\u2713")}
`;
        ctx.task.output = ctx.task.output ? ctx.task.output + output : output;
        finalOutput += output;
        capturedScreenshots++;
      } catch (error) {
        ctx.log.debug(`screenshot capture failed for ${JSON.stringify(staticConfig)}; error: ${error}`);
        let output = `${chalk__default.default.gray(staticConfig.name)} ${chalk__default.default.red("\u2717")}
`;
        ctx.task.output += output;
        finalOutput += output;
      }
    }
    yield closeBrowsers(browsers);
    return { capturedScreenshots, finalOutput };
  });
}
function executeDocumentScripts(ctx, page, actionType, script) {
  return __async(this, null, function* () {
    try {
      if (!page) {
        throw new Error("Page instance not available");
      }
      if (script !== "") {
        yield page.evaluate((script2) => {
          new Function(script2)();
        }, script);
      }
    } catch (error) {
      ctx.log.error(`Error executing script for action ${actionType}: `, error);
      throw error;
    }
  });
}
var captureScreenshots_default = (ctx) => {
  return {
    title: "Capturing screenshots",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        if (ctx2.options.fetchResults) {
          startPolling(ctx2, "", false, "");
        }
        updateLogContext({ task: "capture" });
        if (ctx2.options.parallel) {
          let { totalCapturedScreenshots, output } = yield captureScreenshotsConcurrent(ctx2);
          if (totalCapturedScreenshots != ctx2.webStaticConfig.length) {
            throw new Error(output);
          }
        } else {
          let { capturedScreenshots, output } = yield captureScreenshots(ctx2);
          if (capturedScreenshots != ctx2.webStaticConfig.length) {
            throw new Error(output);
          }
        }
        task.title = "Screenshots captured successfully";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Capturing screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/commander/capture.ts
var command2 = new commander.Command();
command2.name("capture").description("Capture screenshots of static sites").argument("<file>", "Web static config file").option("-C, --parallel [number]", "Specify the number of instances per browser", parseInt).option("-F, --force", "forcefully apply the specified parallel instances per browser").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").option("--buildName <string>", "Specify the build name").option("--scheduled <string>", "Specify the schedule ID").option("--userName <string>", "Specify the LT username").option("--accessKey <string>", "Specify the LT accesskey").action(function(file, _, command11) {
  return __async(this, null, function* () {
    var _a, _b;
    const options = command11.optsWithGlobals();
    if (options.buildName === "") {
      console.log(`Error: The '--buildName' option cannot be an empty string.`);
      process.exit(1);
    }
    let ctx = ctx_default(command11.optsWithGlobals());
    ctx.isSnapshotCaptured = true;
    if (!fs6__default.default.existsSync(file)) {
      ctx.log.error(`Web Static Config file ${file} not found.`);
      return;
    }
    try {
      ctx.webStaticConfig = JSON.parse(fs6__default.default.readFileSync(file, "utf8"));
      if (!validateWebStaticConfig(ctx.webStaticConfig)) {
        ctx.log.debug(JSON.stringify(validateWebStaticConfig.errors, null, 2));
        (_a = validateWebStaticConfig.errors) == null ? void 0 : _a.forEach((error) => {
          if (error.keyword === "additionalProperties") {
            ctx.log.warn(`Additional property "${error.params.additionalProperty}" is not allowed.`);
          } else {
            const validationError = error.message;
            throw new Error(validationError || "Invalid Web Static config found in file : " + file);
          }
        });
        throw new Error((_b = validateWebStaticConfig.errors[0]) == null ? void 0 : _b.message);
      }
      if (ctx.webStaticConfig && ctx.webStaticConfig.length === 0) {
        ctx.log.error(`No URLs found in the specified config file -> ${file}`);
        return;
      }
    } catch (error) {
      ctx.log.error(`Invalid Web Static Config; ${error.message}`);
      process.exitCode = 1;
      return;
    }
    ctx.log.debug(ctx.config);
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        createBuild_default(),
        captureScreenshots_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
      process.exitCode = 1;
      throw new Error();
    }
  });
});
var capture_default = command2;
var uploadScreenshots_default = (ctx) => {
  return {
    title: "Uploading screenshots",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        if (ctx2.options.fetchResults) {
          startPolling(ctx2, "", false, "");
        }
        updateLogContext({ task: "upload" });
        yield uploadScreenshots(ctx2);
        task.title = "Screenshots uploaded successfully";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Uploading screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/commander/upload.ts
var command3 = new commander.Command();
command3.name("upload").description("Upload screenshots from given directory").argument("<directory>", "Path of the directory").option("-R, --ignoreResolutions", "Ignore resolution").option("-F, --files <extensions>", "Comma-separated list of allowed file extensions", (val) => {
  return val.split(",").map((ext) => ext.trim().toLowerCase());
}).option("-E, --removeExtensions", "Strips file extensions from snapshot names").option("-i, --ignoreDir <patterns>", "Comma-separated list of directories to ignore", (val) => {
  return val.split(",").map((pattern) => pattern.trim());
}).option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").option("--buildName <string>", "Specify the build name").option("--userName <string>", "Specify the LT username").option("--accessKey <string>", "Specify the LT accesskey").action(function(directory, _, command11) {
  return __async(this, null, function* () {
    const options = command11.optsWithGlobals();
    if (options.buildName === "") {
      console.log(`Error: The '--buildName' option cannot be an empty string.`);
      process.exit(1);
    }
    let ctx = ctx_default(command11.optsWithGlobals());
    ctx.isSnapshotCaptured = true;
    if (!fs6__default.default.existsSync(directory)) {
      console.log(`Error: The provided directory ${directory} not found.`);
      return;
    }
    if (path3__default.default.extname(directory).toLowerCase() === constants_default.FILE_EXTENSION_ZIP) {
      ctx.log.debug(`Error: The provided directory ${directory} is a zip file. Zips are not accepted.`);
      return;
    }
    ctx.uploadFilePath = directory;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        createBuild_default(),
        uploadScreenshots_default(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
      process.exitCode = 1;
    }
  });
});
var upload_default = command3;

// src/lib/uploadFigmaDesigns.ts
var uploadFigmaDesigns_default = (ctx) => __async(void 0, null, function* () {
  const depth = ctx.figmaDesignConfig.depth;
  const figmaConfigs = ctx.figmaDesignConfig.figma_config;
  let results = "";
  let figmaFileToken = "";
  const markBaseline = ctx.options.markBaseline;
  const buildName = ctx.options.buildName;
  for (const config of figmaConfigs) {
    figmaFileToken = config.figma_file_token;
    let queryParams = "";
    if (config.figma_ids && config.figma_ids.length > 0) {
      const fileIds = config.figma_ids.join(",");
      queryParams += `?ids=${fileIds}`;
    }
    const authToken = `Basic ${Buffer.from(`${ctx.env.LT_USERNAME}:${ctx.env.LT_ACCESS_KEY}`).toString("base64")}`;
    const responseData = yield ctx.client.getFigmaFilesAndImages(figmaFileToken, ctx.env.FIGMA_TOKEN, queryParams, authToken, depth, markBaseline, buildName, ctx.log);
    if (responseData.data.message == "success") {
      results = responseData.data.message;
    }
  }
  return results;
});

// src/tasks/uploadFigmaDesigns.ts
var uploadFigmaDesigns_default2 = (ctx) => {
  return {
    title: "Uploading Figma Designs",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "upload-figma" });
        let results = yield uploadFigmaDesigns_default(ctx2);
        if (results != "success") {
          throw new Error("Uploading Figma designs failed");
        }
        task.title = "Figma designs images uploaded successfully to SmartUI";
        ctx2.log.debug(`Figma designs processed: ${results}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Uploading Figma designs failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};

// src/lib/uploadWebFigma.ts
var uploadWebFigma_default = (ctx) => __async(void 0, null, function* () {
  var _a, _b;
  const figmaConfig = ctx.config && ((_a = ctx.config) == null ? void 0 : _a.figma) || {};
  const webConfig = ctx.config && ((_b = ctx.config) == null ? void 0 : _b.web) || {};
  let results = "";
  const buildName = ctx.options.buildName;
  if (figmaConfig && figmaConfig.configs && figmaConfig.configs.length > 0) {
    const authToken = `Basic ${Buffer.from(`${ctx.env.LT_USERNAME}:${ctx.env.LT_ACCESS_KEY}`).toString("base64")}`;
    const requestBody = {
      figma_token: ctx.env.FIGMA_TOKEN,
      auth: authToken,
      build_name: buildName,
      web: webConfig,
      figma: figmaConfig,
      smartIgnore: ctx.config.smartIgnore,
      git: ctx.git,
      markBaseline: ctx.options.markBaseline
    };
    const responseData = yield ctx.client.processWebFigma(requestBody, ctx.log);
    ctx.log.debug("responseData : " + JSON.stringify(responseData));
    if (responseData && responseData.error && responseData.error.message) {
      throw new Error(responseData.error.message);
    }
    if (responseData.data.message == "success") {
      results = responseData.data.message;
      ctx.build = {
        id: responseData.data.buildId,
        url: responseData.data.buildURL || "https://smartui.lambdatestinternal.com",
        baseline: responseData.data.baseline ? responseData.data.baseline : false
      };
    }
  } else {
    throw new Error("No Figma configuration found in config file");
  }
  return results;
});

// src/lib/fetchFigma.ts
var fetchFigma_default = (ctx) => __async(void 0, null, function* () {
  const buildId = ctx.build.id;
  ctx.log.debug(`Fetching figma results for buildId ${buildId}`);
  const startTime = Date.now();
  try {
    const results = yield callFetchWebFigmaRecursive(startTime, buildId, ctx);
    return results;
  } catch (error) {
    ctx.log.error(`Failed to fetch figma results: ${error}`);
    return { message: "Failed to fetch figma results" };
  }
});
function callFetchWebFigmaRecursive(startTime, buildId, ctx) {
  return __async(this, null, function* () {
    var _a, _b;
    const currentTime = Date.now();
    const elapsedTime = (currentTime - startTime) / 1e3;
    if (elapsedTime >= 180) {
      ctx.log.error("Stopping execution after 5 minutes.");
      throw new Error("Timeout: Fetching figma results took more than 5 minutes.");
    }
    try {
      const response = yield ctx.client.fetchWebFigma(buildId, ctx.log);
      ctx.log.debug("responseData : " + JSON.stringify(response));
      const message = ((_a = response == null ? void 0 : response.data) == null ? void 0 : _a.message) || "";
      if (message === "") {
        ctx.log.debug("No results yet. Retrying after 5 seconds...");
        yield new Promise((resolve) => setTimeout(resolve, 5e3));
        return yield callFetchWebFigmaRecursive(startTime, buildId, ctx);
      } else {
        return (_b = response == null ? void 0 : response.data) == null ? void 0 : _b.message;
      }
    } catch (error) {
      ctx.log.error("Error in fetchWebFigma:", error);
      ctx.log.debug("Retrying after 5 seconds...");
      yield new Promise((resolve) => setTimeout(resolve, 5e3));
      return yield callFetchWebFigmaRecursive(startTime, buildId, ctx);
    }
  });
}

// src/tasks/uploadWebFigma.ts
var uploadWebFigma_default2 = (ctx) => {
  return {
    title: "Processing Web Figma",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "upload-figma-web" });
        let results = yield uploadWebFigma_default(ctx2);
        if (results != "success") {
          throw new Error("Uploading Web Figma Screenshot failed");
        }
        if (ctx2.build.id) {
          task.output = chalk__default.default.gray(`Build Id: ${ctx2.build.id}`);
          let figmaOutput = yield fetchFigma_default(ctx2);
          const jsonObject = JSON.parse(figmaOutput);
          let output = JSON.stringify(jsonObject, null, 2);
          task.output = task.output + "\n" + chalk__default.default.green(`${output}`);
        }
        if (ctx2.options.fetchResults) {
          startPolling(ctx2, "", false, "");
        }
        task.title = "Web Figma images uploaded successfully to SmartUI";
        ctx2.log.debug(`Web Figma processed: ${results}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Uploading Web Figma Screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: true
  };
};

// src/lib/uploadAppFigma.ts
var uploadAppFigma_default = (ctx) => __async(void 0, null, function* () {
  var _a, _b;
  const figmaConfig = ctx.config && ((_a = ctx.config) == null ? void 0 : _a.figma) || {};
  const mobileConfig = ctx.config && ((_b = ctx.config) == null ? void 0 : _b.mobile) || {};
  let results = "";
  const buildName = ctx.options.buildName;
  if (figmaConfig && figmaConfig.configs && figmaConfig.configs.length > 0) {
    const authToken = `Basic ${Buffer.from(`${ctx.env.LT_USERNAME}:${ctx.env.LT_ACCESS_KEY}`).toString("base64")}`;
    const requestBody = {
      figma_token: ctx.env.FIGMA_TOKEN,
      auth: authToken,
      build_name: buildName,
      mobile: mobileConfig,
      figma: figmaConfig,
      smartIgnore: ctx.config.smartIgnore,
      git: ctx.git,
      platformType: "app",
      markBaseline: ctx.options.markBaseline
    };
    const responseData = yield ctx.client.processWebFigma(requestBody, ctx.log);
    ctx.log.debug("responseData : " + JSON.stringify(responseData));
    if (responseData && responseData.error && responseData.error.message) {
      throw new Error(responseData.error.message);
    }
    if (responseData.data.message == "success") {
      results = responseData.data.message;
      ctx.build = {
        id: responseData.data.buildId,
        url: responseData.data.buildURL || "https://smartui.lambdatestinternal.com",
        baseline: responseData.data.baseline ? responseData.data.baseline : false
      };
    }
  } else {
    throw new Error("No Figma configuration found in config file");
  }
  return results;
});

// src/tasks/uploadAppFigma.ts
var uploadAppFigma_default2 = (ctx) => {
  return {
    title: "Processing App Figma",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "upload-figma-app" });
        let results = yield uploadAppFigma_default(ctx2);
        if (results != "success") {
          throw new Error("Uploading App Figma Screenshot failed");
        }
        if (ctx2.build.id) {
          task.output = chalk__default.default.gray(`Build Id: ${ctx2.build.id}`);
          let figmaOutput = yield fetchFigma_default(ctx2);
          const jsonObject = JSON.parse(figmaOutput);
          let output = JSON.stringify(jsonObject, null, 2);
          task.output = task.output + "\n" + chalk__default.default.green(`${output}`);
        }
        if (ctx2.options.fetchResults) {
          startPolling(ctx2, "", false, "");
        }
        task.title = "App Figma images uploaded successfully to SmartUI";
        ctx2.log.debug(`App Figma processed: ${results}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(`${error.message}`);
        throw new Error("Uploading App Figma Screenshots failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: true
  };
};
var uploadFigma = new commander.Command();
var uploadWebFigmaCommand = new commander.Command();
var uploadAppFigmaCommand = new commander.Command();
uploadFigma.name("upload-figma").description("Capture screenshots of static sites").argument("<file>", "figma design config file").option("--markBaseline", "Mark the uploaded images as baseline").option("--buildName <buildName>", "Name of the build").action(function(file, _, command11) {
  return __async(this, null, function* () {
    var _a, _b;
    let ctx = ctx_default(command11.optsWithGlobals());
    ctx.isSnapshotCaptured = true;
    if (!fs6__default.default.existsSync(file)) {
      console.log(`Error: Figma Config file ${file} not found.`);
      return;
    }
    try {
      ctx.figmaDesignConfig = JSON.parse(fs6__default.default.readFileSync(file, "utf8"));
      if (!validateFigmaDesignConfig(ctx.figmaDesignConfig)) {
        const validationError = (_b = (_a = validateFigmaDesignConfig.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message;
        throw new Error(validationError || "Invalid figma design Config");
      }
    } catch (error) {
      console.log(`[smartui] Error: Invalid figma design Config; ${error.message}`);
      return;
    }
    let tasks = new listr2.Listr(
      [
        auth_default(),
        uploadFigmaDesigns_default2()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
uploadWebFigmaCommand.name("upload-figma-web").description("Capture figma screenshots into CLI build").argument("<file>", "figma config config file").option("--markBaseline", "Mark the uploaded images as baseline").option("--buildName <buildName>", "Name of the build").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").action(function(file, _, command11) {
  return __async(this, null, function* () {
    var _a;
    let ctx = ctx_default(command11.optsWithGlobals());
    if (!fs6__default.default.existsSync(file)) {
      console.log(`Error: figma-web config file ${file} not found.`);
      return;
    }
    try {
      ctx.config = JSON.parse(fs6__default.default.readFileSync(file, "utf8"));
      ctx.log.info(JSON.stringify(ctx.config));
      if (!validateWebFigmaConfig(ctx.config)) {
        ctx.log.debug(JSON.stringify(validateWebFigmaConfig.errors, null, 2));
        (_a = validateWebFigmaConfig.errors) == null ? void 0 : _a.forEach((error) => {
          if (error.keyword === "additionalProperties") {
            ctx.log.warn(`Additional property "${error.params.additionalProperty}" is not allowed.`);
          } else {
            const validationError = error.message;
            throw new Error(validationError || "Invalid figma-web config found in file : " + file);
          }
        });
      }
      verifyFigmaWebConfig(ctx);
    } catch (error) {
      ctx.log.error(chalk__default.default.red(`Invalid figma-web config; ${error.message}`));
      process.exitCode = 1;
      return;
    }
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        uploadWebFigma_default2(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
uploadAppFigmaCommand.name("upload-figma-app").description("Capture figma screenshots into App Build").argument("<file>", "figma config config file").option("--markBaseline", "Mark the uploaded images as baseline").option("--buildName <buildName>", "Name of the build").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").action(function(file, _, command11) {
  return __async(this, null, function* () {
    var _a;
    let ctx = ctx_default(command11.optsWithGlobals());
    if (!fs6__default.default.existsSync(file)) {
      console.log(`Error: figma-app config file ${file} not found.`);
      return;
    }
    try {
      ctx.config = JSON.parse(fs6__default.default.readFileSync(file, "utf8"));
      ctx.log.info(JSON.stringify(ctx.config));
      if (!validateAppFigmaConfig(ctx.config)) {
        ctx.log.debug(JSON.stringify(validateAppFigmaConfig.errors, null, 2));
        (_a = validateAppFigmaConfig.errors) == null ? void 0 : _a.forEach((error) => {
          if (error.keyword === "additionalProperties") {
            ctx.log.warn(`Additional property "${error.params.additionalProperty}" is not allowed.`);
          } else {
            const validationError = error.message;
            throw new Error(validationError || "Invalid figma-app config found in file : " + file);
          }
        });
      }
      verifyFigmaWebConfig(ctx);
    } catch (error) {
      ctx.log.error(chalk__default.default.red(`Invalid figma-app config; ${error.message}`));
      process.exitCode = 1;
      return;
    }
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        uploadAppFigma_default2(),
        finalizeBuild_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
    }
  });
});
var command4 = new commander.Command();
command4.name("exec:start").description("Start SmartUI server").option("-P, --port <number>", "Port number for the server").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").option("--buildName <string>", "Specify the build name").action(function() {
  return __async(this, null, function* () {
    var _a;
    const options = command4.optsWithGlobals();
    if (options.buildName === "") {
      console.log(`Error: The '--buildName' option cannot be an empty string.`);
      process.exit(1);
    }
    let ctx = ctx_default(command4.optsWithGlobals());
    ctx.snapshotQueue = new Queue(ctx);
    ctx.totalSnapshots = 0;
    ctx.isStartExec = true;
    ctx.sourceCommand = "exec-start";
    let tasks = new listr2.Listr(
      [
        authExec_default(),
        startServer_default(),
        getGitInfo_default(),
        ...ctx.config.tunnel && ((_a = ctx.config.tunnel) == null ? void 0 : _a.type) === "auto" ? [startTunnel_default()] : [],
        createBuildExec_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
      if (ctx.build && ctx.build.id && !ctx.autoTunnelStarted) {
        startPingPolling(ctx);
      }
      if (ctx.options.fetchResults && ctx.build && ctx.build.id) {
        startPolling(ctx, "", false, "");
      }
    } catch (error) {
      console.error("Error during server execution:", error);
      process.exit(1);
    }
  });
});
var server_default2 = command4;
var command5 = new commander.Command();
function getSmartUIServerAddress() {
  const serverAddress = process.env.SMARTUI_SERVER_ADDRESS || "http://localhost:49152";
  return serverAddress;
}
command5.name("exec:stop").description("Stop the SmartUI server").action(function() {
  return __async(this, null, function* () {
    try {
      const serverAddress = getSmartUIServerAddress();
      console.log(chalk__default.default.yellow(`Stopping server at ${serverAddress} from terminal...`));
      const response = yield axios__default.default.post(`${serverAddress}/stop`, { timeout: 15e3 }, {
        headers: {
          "Content-Type": "application/json"
          // Ensure the correct Content-Type header
        }
      });
      if (response.status === 200) {
        console.log(chalk__default.default.green("Server stopped successfully"));
        console.log(chalk__default.default.green(`Response: ${JSON.stringify(response.data)}`));
      } else {
        console.log(chalk__default.default.red("Failed to stop server"));
      }
    } catch (error) {
      if (error && error.code === "ECONNABORTED") {
        console.error(chalk__default.default.red("Error: SmartUI server did not respond in 15 seconds"));
      }
      if (error && error.code === "ECONNREFUSED") {
        console.error(chalk__default.default.red("Error: Looks like smartui cli server is already stopped"));
      } else {
        console.error(chalk__default.default.red("Error while stopping server"));
      }
    }
  });
});
var stopServer_default = command5;
function getSmartUIServerAddress2() {
  const serverAddress = process.env.SMARTUI_SERVER_ADDRESS || "http://localhost:49152";
  return serverAddress;
}
var command6 = new commander.Command();
command6.name("exec:ping").description("Ping the SmartUI server to check if it is running").action(function() {
  return __async(this, null, function* () {
    try {
      console.log(chalk__default.default.yellow("Pinging server..."));
      const serverAddress = getSmartUIServerAddress2();
      console.log(chalk__default.default.yellow(`Pinging server at ${serverAddress} from terminal...`));
      const response = yield axios__default.default.get(`${serverAddress}/ping`, { timeout: 15e3 });
      if (response.status === 200) {
        console.log(chalk__default.default.green("SmartUI Server is running"));
        console.log(chalk__default.default.green(`Response: ${JSON.stringify(response.data)}`));
      } else {
        console.log(chalk__default.default.red("Failed to reach the server"));
      }
    } catch (error) {
      if (error.code === "ECONNABORTED") {
        console.error(chalk__default.default.red("Error: SmartUI server did not respond in 15 seconds"));
      } else {
        console.error(chalk__default.default.red("SmartUI server is not running"));
        console.error(chalk__default.default.red(`Error: ${error == null ? void 0 : error.code}`));
        console.error(error);
      }
    }
  });
});
var ping_default = command6;
var fetchBranchInfo_default = (ctx) => {
  return {
    title: `Fetching branch info`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "fetchBranchInfo" });
      try {
        if (ctx2.mergeBranchSource === ctx2.mergeBranchTarget) {
          ctx2.log.error(`Merging two similar branch is not possible`);
          throw new Error(`Merging two similar branch is not possible`);
        }
        const requestData = {
          source: ctx2.mergeBranchSource,
          target: ctx2.mergeBranchTarget,
          byBranch: ctx2.mergeByBranch,
          byBuild: ctx2.mergeByBuild
        };
        let resp = yield ctx2.client.fetchBuildInfo(requestData, ctx2);
        if (resp && resp.data && resp.data.source && resp.data.target) {
          ctx2.mergeBuildSourceId = resp.data.source;
          ctx2.mergeBuildTargetId = resp.data.target;
          ctx2.log.debug(`Merge Build source buildId: ${ctx2.mergeBuildSourceId} and target buildId: ${ctx2.mergeBuildTargetId}`);
        } else if (resp && resp.error) {
          if (resp.error.message) {
            ctx2.log.error(`Error while fetching branch Info: ${resp.error.message}`);
            throw new Error(`Error while fetching branch Info: ${resp.error.message}`);
          }
        }
        task.title = "Branch info fetched";
        task.output = chalk__default.default.gray(`Source buildId: ${ctx2.mergeBuildSourceId} and Target buildId: ${ctx2.mergeBuildTargetId}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Branch info fetching failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};
var mergeBuilds_default = (ctx) => {
  return {
    title: `Merging smartui builds`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "mergeBuilds" });
      try {
        let resp;
        if (ctx2.mergeByBranch) {
          ctx2.git.branch = ctx2.mergeBranchTarget;
          const requestData = {
            source: ctx2.mergeBuildSourceId,
            target: ctx2.mergeBuildTargetId,
            byBranch: ctx2.mergeByBranch,
            byBuildName: ctx2.mergeByBuild,
            sourceBranchName: ctx2.mergeBranchSource,
            targetBranchName: ctx2.mergeBranchTarget,
            sourceBuildName: "",
            targetBuildName: "",
            git: ctx2.git
          };
          resp = yield ctx2.client.mergeBuildsByBuildId(requestData, ctx2);
        } else {
          const requestData = {
            source: ctx2.mergeBuildSourceId,
            target: ctx2.mergeBuildTargetId,
            byBranch: ctx2.mergeByBranch,
            byBuildName: ctx2.mergeByBuild,
            sourceBranchName: "",
            targetBranchName: "",
            sourceBuildName: ctx2.mergeBuildSource,
            targetBuildName: ctx2.mergeBuildTarget,
            git: ctx2.git
          };
          resp = yield ctx2.client.mergeBuildsByBuildId(requestData, ctx2);
        }
        if (resp && resp.data && resp.data.message) {
          ctx2.log.debug(`${resp.data.message}`);
        } else {
          ctx2.log.error(`Error while initiating merging process: ${resp.error.message}`);
          throw new Error(`Error while initiating merging process: ${resp.error.message}`);
        }
        task.title = "Merging SmartUI builds initiated";
        task.output = chalk__default.default.gray(`${resp.data.message}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Merging SmartUI build failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// src/commander/mergeBranch.ts
var command7 = new commander.Command();
command7.name("branch").description("Merge a source branch into the target branch").requiredOption("--source <string>", "Source branch to merge").requiredOption("--target <string>", "Target branch to merge into").action(function(options) {
  return __async(this, null, function* () {
    const { source, target } = options;
    let ctx = ctx_default(command7.optsWithGlobals());
    if (!source || source.trim() === "") {
      ctx.log.error("Error: The --source option cannot be empty.");
      process.exit(1);
    }
    if (!target || target.trim() === "") {
      ctx.log.error("Error: The --target option cannot be empty.");
      process.exit(1);
    }
    ctx.log.debug(`Merging source branch '${source}' into branch branch '${target}'`);
    ctx.mergeBranchSource = source;
    ctx.mergeBranchTarget = target;
    ctx.mergeByBranch = true;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        fetchBranchInfo_default(),
        mergeBuilds_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: "\u2192"
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.error("Error during merge operation:", error);
    }
  });
});
var mergeBranch_default = command7;
var fetchBuildInfo_default = (ctx) => {
  return {
    title: `Fetching build info`,
    task: (ctx2, task) => __async(void 0, null, function* () {
      updateLogContext({ task: "fetchBuildInfo" });
      try {
        if (ctx2.mergeBuildSource === ctx2.mergeBuildTarget) {
          ctx2.log.error(`Merging two similar build is not possible`);
          throw new Error(`Merging two similar build is not possible`);
        }
        const requestData = {
          source: ctx2.mergeBuildSource,
          target: ctx2.mergeBuildTarget,
          byBranch: ctx2.mergeByBranch,
          byBuildName: ctx2.mergeByBuild
        };
        let resp = yield ctx2.client.fetchBuildInfo(requestData, ctx2);
        if (resp && resp.data && resp.data.source && resp.data.target) {
          ctx2.mergeBuildSourceId = resp.data.source;
          ctx2.mergeBuildTargetId = resp.data.target;
          ctx2.log.debug(`Merge Build source buildId: ${ctx2.mergeBuildSourceId} and target buildId: ${ctx2.mergeBuildTargetId}`);
        } else if (resp && resp.error) {
          if (resp.error.message) {
            ctx2.log.error(`Error while fetching buildInfo: ${resp.error.message}`);
            throw new Error(`Error while fetching buildInfo: ${resp.error.message}`);
          }
        }
        task.title = "Build info fetched";
        task.output = chalk__default.default.gray(`Source buildId: ${ctx2.mergeBuildSourceId} and Target buildId: ${ctx2.mergeBuildTargetId}`);
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.gray(error.message);
        throw new Error("Build info fetching failed");
      }
    }),
    rendererOptions: { persistentOutput: true }
  };
};

// src/commander/mergeBuild.ts
var command8 = new commander.Command();
command8.name("build").description("Merge a source build into the target build").requiredOption("--source <string>", "Source build to merge").requiredOption("--target <string>", "Target build to merge into").action(function(options) {
  return __async(this, null, function* () {
    const { source, target } = options;
    let ctx = ctx_default(command8.optsWithGlobals());
    if (!source || source.trim() === "") {
      ctx.log.error("Error: The --source option cannot be empty.");
      process.exit(1);
    }
    if (!target || target.trim() === "") {
      ctx.log.error("Error: The --target option cannot be empty.");
      process.exit(1);
    }
    ctx.log.debug(`Merging source build '${source}' into target build '${target}'`);
    ctx.mergeBuildSource = source;
    ctx.mergeBuildTarget = target;
    ctx.mergeByBuild = true;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        getGitInfo_default(),
        fetchBuildInfo_default(),
        mergeBuilds_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: "\u2192"
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
    } catch (error) {
      console.error("Error during merge operation:", error);
      process.exitCode = 1;
    }
  });
});
var mergeBuild_default = command8;

// src/commander/merge.ts
var program = new commander.Command();
program.name("merge").description("Merge a source branch into the target branch").addCommand(mergeBranch_default).addCommand(mergeBuild_default);
var merge_default = program;
function getSmartUIServerAddress3() {
  const serverAddress = process.env.SMARTUI_SERVER_ADDRESS || "http://localhost:49152";
  return serverAddress;
}
function makeHttpRequest(url, timeout) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const isHttps = urlObj.protocol === "https:";
    const client = isHttps ? https__namespace : http__namespace;
    const req = client.request(url, { timeout }, (res) => {
      let data = "";
      res.on("data", (chunk) => {
        data += chunk;
      });
      res.on("end", () => {
        let parsedData;
        try {
          parsedData = JSON.parse(data);
        } catch (e) {
          parsedData = data;
        }
        resolve({
          status: res.statusCode || 0,
          data: parsedData
        });
      });
    });
    req.on("error", (error) => {
      console.error(error);
      reject(error);
    });
    req.on("timeout", () => {
      req.destroy();
      const timeoutError = new Error("Request timeout");
      timeoutError.code = "ECONNABORTED";
      reject(timeoutError);
    });
    req.end();
  });
}
var command9 = new commander.Command();
command9.name("exec:pingTest").description("Ping the SmartUI server to check if it is running using default http client").action(function() {
  return __async(this, null, function* () {
    try {
      console.log(chalk__default.default.yellow("Pinging server using default http client..."));
      const serverAddress = getSmartUIServerAddress3();
      console.log(chalk__default.default.yellow(`Pinging server at ${serverAddress} from terminal using default http client...`));
      const response = yield makeHttpRequest(`${serverAddress}/ping`, 15e3);
      if (response.status === 200) {
        console.log(chalk__default.default.green("SmartUI Server is running"));
        console.log(chalk__default.default.green(`Response: ${JSON.stringify(response.data)}`));
      } else {
        console.log(chalk__default.default.red("Failed to reach the server"));
      }
    } catch (error) {
      if (error.code === "ECONNABORTED") {
        console.error(chalk__default.default.red("Error: SmartUI server did not respond in 15 seconds"));
      } else {
        console.error(chalk__default.default.red("SmartUI server is not running"));
        console.error(chalk__default.default.red(`Error: ${error == null ? void 0 : error.code}`));
        console.error(error);
      }
    }
  });
});
var pingTest_default = command9;
var uploadPdfs_default = (ctx) => {
  return {
    title: "Uploading PDFs",
    task: (ctx2, task) => __async(void 0, null, function* () {
      try {
        ctx2.task = task;
        updateLogContext({ task: "upload-pdf" });
        yield uploadPdfs(ctx2, ctx2.uploadFilePath);
        task.title = "PDFs uploaded successfully";
      } catch (error) {
        ctx2.log.debug(error);
        task.output = chalk__default.default.red(`${error.message}`);
        throw new Error("PDF upload failed");
      }
    }),
    rendererOptions: { persistentOutput: true },
    exitOnError: false
  };
};
function uploadPdfs(ctx, pdfPath) {
  return __async(this, null, function* () {
    const formData = new FormData__default.default();
    if (pdfPath.endsWith(".pdf")) {
      formData.append("pathToFiles", fs6__default.default.createReadStream(pdfPath));
    } else {
      const files = fs6__default.default.readdirSync(pdfPath);
      const pdfFiles = files.filter((file) => file.endsWith(".pdf"));
      pdfFiles.forEach((pdf) => {
        const filePath = path3__default.default.join(pdfPath, pdf);
        formData.append("pathToFiles", fs6__default.default.createReadStream(filePath));
      });
    }
    const buildName = ctx.options.buildName;
    if (buildName) {
      ctx.build.name = buildName;
    }
    try {
      const response = yield ctx.client.uploadPdf(ctx, formData, buildName);
      if (response && response.buildId) {
        ctx.build.id = response.buildId;
        ctx.log.debug(`PDF upload successful. Build ID: ${ctx.build.id}`);
      }
      if (response && response.projectId) {
        ctx.build.projectId = response.projectId;
      }
    } catch (error) {
      throw new Error(error.message);
    }
  });
}

// src/commander/uploadPdf.ts
var command10 = new commander.Command();
command10.name("upload-pdf").description("Upload PDFs for visual comparison").argument("<directory>", "Path of the directory containing PDFs").option("--fetch-results [filename]", "Fetch results and optionally specify an output file, e.g., <filename>.json").option("--buildName <string>", "Specify the build name").option("--markBaseline", "Mark this build baseline").action(function(directory, _, command11) {
  return __async(this, null, function* () {
    const options = command11.optsWithGlobals();
    if (options.buildName === "") {
      console.log(`Error: The '--buildName' option cannot be an empty string.`);
      process.exit(1);
    }
    let ctx = ctx_default(command11.optsWithGlobals());
    if (!fs6__default.default.existsSync(directory)) {
      console.log(`Error: The provided directory ${directory} not found.`);
      process.exit(1);
    }
    ctx.uploadFilePath = directory;
    let tasks = new listr2.Listr(
      [
        auth_default(),
        uploadPdfs_default()
      ],
      {
        rendererOptions: {
          icon: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: `\u2192`
          },
          color: {
            [listr2.ListrDefaultRendererLogLevels.OUTPUT]: listr2.color.gray
          }
        }
      }
    );
    try {
      yield tasks.run(ctx);
      if (ctx.options.fetchResults) {
        startPdfPolling(ctx);
      }
    } catch (error) {
      console.log("\nRefer docs: https://www.lambdatest.com/support/docs/smart-visual-regression-testing/");
      process.exit(1);
    }
  });
});
var uploadPdf_default = command10;

// src/commander/commander.ts
var program2 = new commander.Command();
program2.name("smartui").description("CLI to help you run your SmartUI tests on LambdaTest platform").version(`v${version}`).option("-c --config <filepath>", "Config file path").option("--markBaseline", "Mark this build baseline").option("--baselineBranch <string>", "Mark this build baseline").option("--baselineBuild <string>", "Mark this build baseline").option("--githubURL <string>", "GitHub URL including commitId").option("--gitURL <string>", "Git URL including commitId").option("--userName <string>", "Specify the LT username").option("--accessKey <string>", "Specify the LT accesskey").addCommand(exec_default2).addCommand(capture_default).addCommand(configWeb).addCommand(configStatic).addCommand(upload_default).addCommand(server_default2).addCommand(stopServer_default).addCommand(merge_default).addCommand(ping_default).addCommand(configFigma).addCommand(uploadFigma).addCommand(configWebFigma).addCommand(configAppFigma).addCommand(uploadWebFigmaCommand).addCommand(uploadAppFigmaCommand).addCommand(pingTest_default).addCommand(uploadPdf_default);
var commander_default = program2;
(function() {
  return __async(this, null, function* () {
    let client = new httpClient(env_default());
    let log2 = logger_default;
    try {
      fs6__default.default.unlinkSync(constants_default.LOG_FILE_PATH);
      let { data: { latestVersion, deprecated, additionalDescription } } = yield client.checkUpdate(log2);
      log2.info(`
LambdaTest SmartUI CLI v${package_default.version}`);
      log2.info(chalk__default.default.yellow(`${additionalDescription}`));
      if (deprecated) {
        log2.warn(`This version is deprecated. A new version ${latestVersion} is available!`);
      } else if (package_default.version !== latestVersion) {
        log2.info(chalk__default.default.green(`A new version ${latestVersion} is available!`));
      } else
        log2.info(chalk__default.default.gray("https://www.npmjs.com/package/@lambdatest/smartui-cli\n"));
    } catch (error) {
      log2.debug(error);
      log2.info(chalk__default.default.gray("https://www.npmjs.com/package/@lambdatest/smartui-cli\n"));
    }
    commander_default.parse();
  });
})();
